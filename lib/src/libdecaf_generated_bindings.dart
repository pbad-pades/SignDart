// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

class Libdecaf {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Libdecaf(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Libdecaf.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  int select(
    int __nfds,
    ffi.Pointer<fd_set> __readfds,
    ffi.Pointer<fd_set> __writefds,
    ffi.Pointer<fd_set> __exceptfds,
    ffi.Pointer<timeval> __timeout,
  ) {
    return _select(
      __nfds,
      __readfds,
      __writefds,
      __exceptfds,
      __timeout,
    );
  }

  late final _select_ptr = _lookup<ffi.NativeFunction<_c_select>>('select');
  late final _dart_select _select = _select_ptr.asFunction<_dart_select>();

  int pselect(
    int __nfds,
    ffi.Pointer<fd_set> __readfds,
    ffi.Pointer<fd_set> __writefds,
    ffi.Pointer<fd_set> __exceptfds,
    ffi.Pointer<timespec> __timeout,
    ffi.Pointer<__sigset_t> __sigmask,
  ) {
    return _pselect(
      __nfds,
      __readfds,
      __writefds,
      __exceptfds,
      __timeout,
      __sigmask,
    );
  }

  late final _pselect_ptr = _lookup<ffi.NativeFunction<_c_pselect>>('pselect');
  late final _dart_pselect _pselect = _pselect_ptr.asFunction<_dart_pselect>();

  int __ctype_get_mb_cur_max() {
    return ___ctype_get_mb_cur_max();
  }

  late final ___ctype_get_mb_cur_max_ptr =
      _lookup<ffi.NativeFunction<_c___ctype_get_mb_cur_max>>(
          '__ctype_get_mb_cur_max');
  late final _dart___ctype_get_mb_cur_max ___ctype_get_mb_cur_max =
      ___ctype_get_mb_cur_max_ptr.asFunction<_dart___ctype_get_mb_cur_max>();

  double atof(
    ffi.Pointer<ffi.Int8> __nptr,
  ) {
    return _atof(
      __nptr,
    );
  }

  late final _atof_ptr = _lookup<ffi.NativeFunction<_c_atof>>('atof');
  late final _dart_atof _atof = _atof_ptr.asFunction<_dart_atof>();

  int atoi(
    ffi.Pointer<ffi.Int8> __nptr,
  ) {
    return _atoi(
      __nptr,
    );
  }

  late final _atoi_ptr = _lookup<ffi.NativeFunction<_c_atoi>>('atoi');
  late final _dart_atoi _atoi = _atoi_ptr.asFunction<_dart_atoi>();

  int atol(
    ffi.Pointer<ffi.Int8> __nptr,
  ) {
    return _atol(
      __nptr,
    );
  }

  late final _atol_ptr = _lookup<ffi.NativeFunction<_c_atol>>('atol');
  late final _dart_atol _atol = _atol_ptr.asFunction<_dart_atol>();

  int atoll(
    ffi.Pointer<ffi.Int8> __nptr,
  ) {
    return _atoll(
      __nptr,
    );
  }

  late final _atoll_ptr = _lookup<ffi.NativeFunction<_c_atoll>>('atoll');
  late final _dart_atoll _atoll = _atoll_ptr.asFunction<_dart_atoll>();

  double strtod(
    ffi.Pointer<ffi.Int8> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  ) {
    return _strtod(
      __nptr,
      __endptr,
    );
  }

  late final _strtod_ptr = _lookup<ffi.NativeFunction<_c_strtod>>('strtod');
  late final _dart_strtod _strtod = _strtod_ptr.asFunction<_dart_strtod>();

  double strtof(
    ffi.Pointer<ffi.Int8> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  ) {
    return _strtof(
      __nptr,
      __endptr,
    );
  }

  late final _strtof_ptr = _lookup<ffi.NativeFunction<_c_strtof>>('strtof');
  late final _dart_strtof _strtof = _strtof_ptr.asFunction<_dart_strtof>();

  int strtol(
    ffi.Pointer<ffi.Int8> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
    int __base,
  ) {
    return _strtol(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtol_ptr = _lookup<ffi.NativeFunction<_c_strtol>>('strtol');
  late final _dart_strtol _strtol = _strtol_ptr.asFunction<_dart_strtol>();

  int strtoul(
    ffi.Pointer<ffi.Int8> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
    int __base,
  ) {
    return _strtoul(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoul_ptr = _lookup<ffi.NativeFunction<_c_strtoul>>('strtoul');
  late final _dart_strtoul _strtoul = _strtoul_ptr.asFunction<_dart_strtoul>();

  int strtoq(
    ffi.Pointer<ffi.Int8> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
    int __base,
  ) {
    return _strtoq(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoq_ptr = _lookup<ffi.NativeFunction<_c_strtoq>>('strtoq');
  late final _dart_strtoq _strtoq = _strtoq_ptr.asFunction<_dart_strtoq>();

  int strtouq(
    ffi.Pointer<ffi.Int8> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
    int __base,
  ) {
    return _strtouq(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtouq_ptr = _lookup<ffi.NativeFunction<_c_strtouq>>('strtouq');
  late final _dart_strtouq _strtouq = _strtouq_ptr.asFunction<_dart_strtouq>();

  int strtoll(
    ffi.Pointer<ffi.Int8> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
    int __base,
  ) {
    return _strtoll(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoll_ptr = _lookup<ffi.NativeFunction<_c_strtoll>>('strtoll');
  late final _dart_strtoll _strtoll = _strtoll_ptr.asFunction<_dart_strtoll>();

  int strtoull(
    ffi.Pointer<ffi.Int8> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
    int __base,
  ) {
    return _strtoull(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoull_ptr =
      _lookup<ffi.NativeFunction<_c_strtoull>>('strtoull');
  late final _dart_strtoull _strtoull =
      _strtoull_ptr.asFunction<_dart_strtoull>();

  ffi.Pointer<ffi.Int8> l64a(
    int __n,
  ) {
    return _l64a(
      __n,
    );
  }

  late final _l64a_ptr = _lookup<ffi.NativeFunction<_c_l64a>>('l64a');
  late final _dart_l64a _l64a = _l64a_ptr.asFunction<_dart_l64a>();

  int a64l(
    ffi.Pointer<ffi.Int8> __s,
  ) {
    return _a64l(
      __s,
    );
  }

  late final _a64l_ptr = _lookup<ffi.NativeFunction<_c_a64l>>('a64l');
  late final _dart_a64l _a64l = _a64l_ptr.asFunction<_dart_a64l>();

  int random() {
    return _random();
  }

  late final _random_ptr = _lookup<ffi.NativeFunction<_c_random>>('random');
  late final _dart_random _random = _random_ptr.asFunction<_dart_random>();

  void srandom(
    int __seed,
  ) {
    return _srandom(
      __seed,
    );
  }

  late final _srandom_ptr = _lookup<ffi.NativeFunction<_c_srandom>>('srandom');
  late final _dart_srandom _srandom = _srandom_ptr.asFunction<_dart_srandom>();

  ffi.Pointer<ffi.Int8> initstate(
    int __seed,
    ffi.Pointer<ffi.Int8> __statebuf,
    int __statelen,
  ) {
    return _initstate(
      __seed,
      __statebuf,
      __statelen,
    );
  }

  late final _initstate_ptr =
      _lookup<ffi.NativeFunction<_c_initstate>>('initstate');
  late final _dart_initstate _initstate =
      _initstate_ptr.asFunction<_dart_initstate>();

  ffi.Pointer<ffi.Int8> setstate(
    ffi.Pointer<ffi.Int8> __statebuf,
  ) {
    return _setstate(
      __statebuf,
    );
  }

  late final _setstate_ptr =
      _lookup<ffi.NativeFunction<_c_setstate>>('setstate');
  late final _dart_setstate _setstate =
      _setstate_ptr.asFunction<_dart_setstate>();

  int random_r(
    ffi.Pointer<random_data> __buf,
    ffi.Pointer<ffi.Int32> __result,
  ) {
    return _random_r(
      __buf,
      __result,
    );
  }

  late final _random_r_ptr =
      _lookup<ffi.NativeFunction<_c_random_r>>('random_r');
  late final _dart_random_r _random_r =
      _random_r_ptr.asFunction<_dart_random_r>();

  int srandom_r(
    int __seed,
    ffi.Pointer<random_data> __buf,
  ) {
    return _srandom_r(
      __seed,
      __buf,
    );
  }

  late final _srandom_r_ptr =
      _lookup<ffi.NativeFunction<_c_srandom_r>>('srandom_r');
  late final _dart_srandom_r _srandom_r =
      _srandom_r_ptr.asFunction<_dart_srandom_r>();

  int initstate_r(
    int __seed,
    ffi.Pointer<ffi.Int8> __statebuf,
    int __statelen,
    ffi.Pointer<random_data> __buf,
  ) {
    return _initstate_r(
      __seed,
      __statebuf,
      __statelen,
      __buf,
    );
  }

  late final _initstate_r_ptr =
      _lookup<ffi.NativeFunction<_c_initstate_r>>('initstate_r');
  late final _dart_initstate_r _initstate_r =
      _initstate_r_ptr.asFunction<_dart_initstate_r>();

  int setstate_r(
    ffi.Pointer<ffi.Int8> __statebuf,
    ffi.Pointer<random_data> __buf,
  ) {
    return _setstate_r(
      __statebuf,
      __buf,
    );
  }

  late final _setstate_r_ptr =
      _lookup<ffi.NativeFunction<_c_setstate_r>>('setstate_r');
  late final _dart_setstate_r _setstate_r =
      _setstate_r_ptr.asFunction<_dart_setstate_r>();

  int rand() {
    return _rand();
  }

  late final _rand_ptr = _lookup<ffi.NativeFunction<_c_rand>>('rand');
  late final _dart_rand _rand = _rand_ptr.asFunction<_dart_rand>();

  void srand(
    int __seed,
  ) {
    return _srand(
      __seed,
    );
  }

  late final _srand_ptr = _lookup<ffi.NativeFunction<_c_srand>>('srand');
  late final _dart_srand _srand = _srand_ptr.asFunction<_dart_srand>();

  int rand_r(
    ffi.Pointer<ffi.Uint32> __seed,
  ) {
    return _rand_r(
      __seed,
    );
  }

  late final _rand_r_ptr = _lookup<ffi.NativeFunction<_c_rand_r>>('rand_r');
  late final _dart_rand_r _rand_r = _rand_r_ptr.asFunction<_dart_rand_r>();

  double drand48() {
    return _drand48();
  }

  late final _drand48_ptr = _lookup<ffi.NativeFunction<_c_drand48>>('drand48');
  late final _dart_drand48 _drand48 = _drand48_ptr.asFunction<_dart_drand48>();

  double erand48(
    ffi.Pointer<ffi.Uint16> __xsubi,
  ) {
    return _erand48(
      __xsubi,
    );
  }

  late final _erand48_ptr = _lookup<ffi.NativeFunction<_c_erand48>>('erand48');
  late final _dart_erand48 _erand48 = _erand48_ptr.asFunction<_dart_erand48>();

  int lrand48() {
    return _lrand48();
  }

  late final _lrand48_ptr = _lookup<ffi.NativeFunction<_c_lrand48>>('lrand48');
  late final _dart_lrand48 _lrand48 = _lrand48_ptr.asFunction<_dart_lrand48>();

  int nrand48(
    ffi.Pointer<ffi.Uint16> __xsubi,
  ) {
    return _nrand48(
      __xsubi,
    );
  }

  late final _nrand48_ptr = _lookup<ffi.NativeFunction<_c_nrand48>>('nrand48');
  late final _dart_nrand48 _nrand48 = _nrand48_ptr.asFunction<_dart_nrand48>();

  int mrand48() {
    return _mrand48();
  }

  late final _mrand48_ptr = _lookup<ffi.NativeFunction<_c_mrand48>>('mrand48');
  late final _dart_mrand48 _mrand48 = _mrand48_ptr.asFunction<_dart_mrand48>();

  int jrand48(
    ffi.Pointer<ffi.Uint16> __xsubi,
  ) {
    return _jrand48(
      __xsubi,
    );
  }

  late final _jrand48_ptr = _lookup<ffi.NativeFunction<_c_jrand48>>('jrand48');
  late final _dart_jrand48 _jrand48 = _jrand48_ptr.asFunction<_dart_jrand48>();

  void srand48(
    int __seedval,
  ) {
    return _srand48(
      __seedval,
    );
  }

  late final _srand48_ptr = _lookup<ffi.NativeFunction<_c_srand48>>('srand48');
  late final _dart_srand48 _srand48 = _srand48_ptr.asFunction<_dart_srand48>();

  ffi.Pointer<ffi.Uint16> seed48(
    ffi.Pointer<ffi.Uint16> __seed16v,
  ) {
    return _seed48(
      __seed16v,
    );
  }

  late final _seed48_ptr = _lookup<ffi.NativeFunction<_c_seed48>>('seed48');
  late final _dart_seed48 _seed48 = _seed48_ptr.asFunction<_dart_seed48>();

  void lcong48(
    ffi.Pointer<ffi.Uint16> __param,
  ) {
    return _lcong48(
      __param,
    );
  }

  late final _lcong48_ptr = _lookup<ffi.NativeFunction<_c_lcong48>>('lcong48');
  late final _dart_lcong48 _lcong48 = _lcong48_ptr.asFunction<_dart_lcong48>();

  int drand48_r(
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Double> __result,
  ) {
    return _drand48_r(
      __buffer,
      __result,
    );
  }

  late final _drand48_r_ptr =
      _lookup<ffi.NativeFunction<_c_drand48_r>>('drand48_r');
  late final _dart_drand48_r _drand48_r =
      _drand48_r_ptr.asFunction<_dart_drand48_r>();

  int erand48_r(
    ffi.Pointer<ffi.Uint16> __xsubi,
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Double> __result,
  ) {
    return _erand48_r(
      __xsubi,
      __buffer,
      __result,
    );
  }

  late final _erand48_r_ptr =
      _lookup<ffi.NativeFunction<_c_erand48_r>>('erand48_r');
  late final _dart_erand48_r _erand48_r =
      _erand48_r_ptr.asFunction<_dart_erand48_r>();

  int lrand48_r(
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Int64> __result,
  ) {
    return _lrand48_r(
      __buffer,
      __result,
    );
  }

  late final _lrand48_r_ptr =
      _lookup<ffi.NativeFunction<_c_lrand48_r>>('lrand48_r');
  late final _dart_lrand48_r _lrand48_r =
      _lrand48_r_ptr.asFunction<_dart_lrand48_r>();

  int nrand48_r(
    ffi.Pointer<ffi.Uint16> __xsubi,
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Int64> __result,
  ) {
    return _nrand48_r(
      __xsubi,
      __buffer,
      __result,
    );
  }

  late final _nrand48_r_ptr =
      _lookup<ffi.NativeFunction<_c_nrand48_r>>('nrand48_r');
  late final _dart_nrand48_r _nrand48_r =
      _nrand48_r_ptr.asFunction<_dart_nrand48_r>();

  int mrand48_r(
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Int64> __result,
  ) {
    return _mrand48_r(
      __buffer,
      __result,
    );
  }

  late final _mrand48_r_ptr =
      _lookup<ffi.NativeFunction<_c_mrand48_r>>('mrand48_r');
  late final _dart_mrand48_r _mrand48_r =
      _mrand48_r_ptr.asFunction<_dart_mrand48_r>();

  int jrand48_r(
    ffi.Pointer<ffi.Uint16> __xsubi,
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Int64> __result,
  ) {
    return _jrand48_r(
      __xsubi,
      __buffer,
      __result,
    );
  }

  late final _jrand48_r_ptr =
      _lookup<ffi.NativeFunction<_c_jrand48_r>>('jrand48_r');
  late final _dart_jrand48_r _jrand48_r =
      _jrand48_r_ptr.asFunction<_dart_jrand48_r>();

  int srand48_r(
    int __seedval,
    ffi.Pointer<drand48_data> __buffer,
  ) {
    return _srand48_r(
      __seedval,
      __buffer,
    );
  }

  late final _srand48_r_ptr =
      _lookup<ffi.NativeFunction<_c_srand48_r>>('srand48_r');
  late final _dart_srand48_r _srand48_r =
      _srand48_r_ptr.asFunction<_dart_srand48_r>();

  int seed48_r(
    ffi.Pointer<ffi.Uint16> __seed16v,
    ffi.Pointer<drand48_data> __buffer,
  ) {
    return _seed48_r(
      __seed16v,
      __buffer,
    );
  }

  late final _seed48_r_ptr =
      _lookup<ffi.NativeFunction<_c_seed48_r>>('seed48_r');
  late final _dart_seed48_r _seed48_r =
      _seed48_r_ptr.asFunction<_dart_seed48_r>();

  int lcong48_r(
    ffi.Pointer<ffi.Uint16> __param,
    ffi.Pointer<drand48_data> __buffer,
  ) {
    return _lcong48_r(
      __param,
      __buffer,
    );
  }

  late final _lcong48_r_ptr =
      _lookup<ffi.NativeFunction<_c_lcong48_r>>('lcong48_r');
  late final _dart_lcong48_r _lcong48_r =
      _lcong48_r_ptr.asFunction<_dart_lcong48_r>();

  ffi.Pointer<ffi.Void> malloc(
    int __size,
  ) {
    return _malloc(
      __size,
    );
  }

  late final _malloc_ptr = _lookup<ffi.NativeFunction<_c_malloc>>('malloc');
  late final _dart_malloc _malloc = _malloc_ptr.asFunction<_dart_malloc>();

  ffi.Pointer<ffi.Void> calloc(
    int __nmemb,
    int __size,
  ) {
    return _calloc(
      __nmemb,
      __size,
    );
  }

  late final _calloc_ptr = _lookup<ffi.NativeFunction<_c_calloc>>('calloc');
  late final _dart_calloc _calloc = _calloc_ptr.asFunction<_dart_calloc>();

  ffi.Pointer<ffi.Void> realloc(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
  ) {
    return _realloc(
      __ptr,
      __size,
    );
  }

  late final _realloc_ptr = _lookup<ffi.NativeFunction<_c_realloc>>('realloc');
  late final _dart_realloc _realloc = _realloc_ptr.asFunction<_dart_realloc>();

  ffi.Pointer<ffi.Void> reallocarray(
    ffi.Pointer<ffi.Void> __ptr,
    int __nmemb,
    int __size,
  ) {
    return _reallocarray(
      __ptr,
      __nmemb,
      __size,
    );
  }

  late final _reallocarray_ptr =
      _lookup<ffi.NativeFunction<_c_reallocarray>>('reallocarray');
  late final _dart_reallocarray _reallocarray =
      _reallocarray_ptr.asFunction<_dart_reallocarray>();

  void free(
    ffi.Pointer<ffi.Void> __ptr,
  ) {
    return _free(
      __ptr,
    );
  }

  late final _free_ptr = _lookup<ffi.NativeFunction<_c_free>>('free');
  late final _dart_free _free = _free_ptr.asFunction<_dart_free>();

  ffi.Pointer<ffi.Void> alloca(
    int __size,
  ) {
    return _alloca(
      __size,
    );
  }

  late final _alloca_ptr = _lookup<ffi.NativeFunction<_c_alloca>>('alloca');
  late final _dart_alloca _alloca = _alloca_ptr.asFunction<_dart_alloca>();

  ffi.Pointer<ffi.Void> valloc(
    int __size,
  ) {
    return _valloc(
      __size,
    );
  }

  late final _valloc_ptr = _lookup<ffi.NativeFunction<_c_valloc>>('valloc');
  late final _dart_valloc _valloc = _valloc_ptr.asFunction<_dart_valloc>();

  int posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> __memptr,
    int __alignment,
    int __size,
  ) {
    return _posix_memalign(
      __memptr,
      __alignment,
      __size,
    );
  }

  late final _posix_memalign_ptr =
      _lookup<ffi.NativeFunction<_c_posix_memalign>>('posix_memalign');
  late final _dart_posix_memalign _posix_memalign =
      _posix_memalign_ptr.asFunction<_dart_posix_memalign>();

  ffi.Pointer<ffi.Void> aligned_alloc(
    int __alignment,
    int __size,
  ) {
    return _aligned_alloc(
      __alignment,
      __size,
    );
  }

  late final _aligned_alloc_ptr =
      _lookup<ffi.NativeFunction<_c_aligned_alloc>>('aligned_alloc');
  late final _dart_aligned_alloc _aligned_alloc =
      _aligned_alloc_ptr.asFunction<_dart_aligned_alloc>();

  void abort() {
    return _abort();
  }

  late final _abort_ptr = _lookup<ffi.NativeFunction<_c_abort>>('abort');
  late final _dart_abort _abort = _abort_ptr.asFunction<_dart_abort>();

  int atexit(
    ffi.Pointer<ffi.NativeFunction<_typedefC_1>> __func,
  ) {
    return _atexit(
      __func,
    );
  }

  late final _atexit_ptr = _lookup<ffi.NativeFunction<_c_atexit>>('atexit');
  late final _dart_atexit _atexit = _atexit_ptr.asFunction<_dart_atexit>();

  int at_quick_exit(
    ffi.Pointer<ffi.NativeFunction<_typedefC_2>> __func,
  ) {
    return _at_quick_exit(
      __func,
    );
  }

  late final _at_quick_exit_ptr =
      _lookup<ffi.NativeFunction<_c_at_quick_exit>>('at_quick_exit');
  late final _dart_at_quick_exit _at_quick_exit =
      _at_quick_exit_ptr.asFunction<_dart_at_quick_exit>();

  int on_exit(
    ffi.Pointer<ffi.NativeFunction<_typedefC_3>> __func,
    ffi.Pointer<ffi.Void> __arg,
  ) {
    return _on_exit(
      __func,
      __arg,
    );
  }

  late final _on_exit_ptr = _lookup<ffi.NativeFunction<_c_on_exit>>('on_exit');
  late final _dart_on_exit _on_exit = _on_exit_ptr.asFunction<_dart_on_exit>();

  void exit(
    int __status,
  ) {
    return _exit(
      __status,
    );
  }

  late final _exit_ptr = _lookup<ffi.NativeFunction<_c_exit>>('exit');
  late final _dart_exit _exit = _exit_ptr.asFunction<_dart_exit>();

  void quick_exit(
    int __status,
  ) {
    return _quick_exit(
      __status,
    );
  }

  late final _quick_exit_ptr =
      _lookup<ffi.NativeFunction<_c_quick_exit>>('quick_exit');
  late final _dart_quick_exit _quick_exit =
      _quick_exit_ptr.asFunction<_dart_quick_exit>();

  void _Exit(
    int __status,
  ) {
    return __Exit(
      __status,
    );
  }

  late final __Exit_ptr = _lookup<ffi.NativeFunction<_c__Exit>>('_Exit');
  late final _dart__Exit __Exit = __Exit_ptr.asFunction<_dart__Exit>();

  ffi.Pointer<ffi.Int8> getenv(
    ffi.Pointer<ffi.Int8> __name,
  ) {
    return _getenv(
      __name,
    );
  }

  late final _getenv_ptr = _lookup<ffi.NativeFunction<_c_getenv>>('getenv');
  late final _dart_getenv _getenv = _getenv_ptr.asFunction<_dart_getenv>();

  int putenv(
    ffi.Pointer<ffi.Int8> __string,
  ) {
    return _putenv(
      __string,
    );
  }

  late final _putenv_ptr = _lookup<ffi.NativeFunction<_c_putenv>>('putenv');
  late final _dart_putenv _putenv = _putenv_ptr.asFunction<_dart_putenv>();

  int setenv(
    ffi.Pointer<ffi.Int8> __name,
    ffi.Pointer<ffi.Int8> __value,
    int __replace,
  ) {
    return _setenv(
      __name,
      __value,
      __replace,
    );
  }

  late final _setenv_ptr = _lookup<ffi.NativeFunction<_c_setenv>>('setenv');
  late final _dart_setenv _setenv = _setenv_ptr.asFunction<_dart_setenv>();

  int unsetenv(
    ffi.Pointer<ffi.Int8> __name,
  ) {
    return _unsetenv(
      __name,
    );
  }

  late final _unsetenv_ptr =
      _lookup<ffi.NativeFunction<_c_unsetenv>>('unsetenv');
  late final _dart_unsetenv _unsetenv =
      _unsetenv_ptr.asFunction<_dart_unsetenv>();

  int clearenv() {
    return _clearenv();
  }

  late final _clearenv_ptr =
      _lookup<ffi.NativeFunction<_c_clearenv>>('clearenv');
  late final _dart_clearenv _clearenv =
      _clearenv_ptr.asFunction<_dart_clearenv>();

  ffi.Pointer<ffi.Int8> mktemp(
    ffi.Pointer<ffi.Int8> __template,
  ) {
    return _mktemp(
      __template,
    );
  }

  late final _mktemp_ptr = _lookup<ffi.NativeFunction<_c_mktemp>>('mktemp');
  late final _dart_mktemp _mktemp = _mktemp_ptr.asFunction<_dart_mktemp>();

  int mkstemp(
    ffi.Pointer<ffi.Int8> __template,
  ) {
    return _mkstemp(
      __template,
    );
  }

  late final _mkstemp_ptr = _lookup<ffi.NativeFunction<_c_mkstemp>>('mkstemp');
  late final _dart_mkstemp _mkstemp = _mkstemp_ptr.asFunction<_dart_mkstemp>();

  int mkstemps(
    ffi.Pointer<ffi.Int8> __template,
    int __suffixlen,
  ) {
    return _mkstemps(
      __template,
      __suffixlen,
    );
  }

  late final _mkstemps_ptr =
      _lookup<ffi.NativeFunction<_c_mkstemps>>('mkstemps');
  late final _dart_mkstemps _mkstemps =
      _mkstemps_ptr.asFunction<_dart_mkstemps>();

  ffi.Pointer<ffi.Int8> mkdtemp(
    ffi.Pointer<ffi.Int8> __template,
  ) {
    return _mkdtemp(
      __template,
    );
  }

  late final _mkdtemp_ptr = _lookup<ffi.NativeFunction<_c_mkdtemp>>('mkdtemp');
  late final _dart_mkdtemp _mkdtemp = _mkdtemp_ptr.asFunction<_dart_mkdtemp>();

  int system(
    ffi.Pointer<ffi.Int8> __command,
  ) {
    return _system(
      __command,
    );
  }

  late final _system_ptr = _lookup<ffi.NativeFunction<_c_system>>('system');
  late final _dart_system _system = _system_ptr.asFunction<_dart_system>();

  ffi.Pointer<ffi.Int8> realpath(
    ffi.Pointer<ffi.Int8> __name,
    ffi.Pointer<ffi.Int8> __resolved,
  ) {
    return _realpath(
      __name,
      __resolved,
    );
  }

  late final _realpath_ptr =
      _lookup<ffi.NativeFunction<_c_realpath>>('realpath');
  late final _dart_realpath _realpath =
      _realpath_ptr.asFunction<_dart_realpath>();

  ffi.Pointer<ffi.Void> bsearch(
    ffi.Pointer<ffi.Void> __key,
    ffi.Pointer<ffi.Void> __base,
    int __nmemb,
    int __size,
    ffi.Pointer<ffi.NativeFunction<__compar_fn_t>> __compar,
  ) {
    return _bsearch(
      __key,
      __base,
      __nmemb,
      __size,
      __compar,
    );
  }

  late final _bsearch_ptr = _lookup<ffi.NativeFunction<_c_bsearch>>('bsearch');
  late final _dart_bsearch _bsearch = _bsearch_ptr.asFunction<_dart_bsearch>();

  void qsort(
    ffi.Pointer<ffi.Void> __base,
    int __nmemb,
    int __size,
    ffi.Pointer<ffi.NativeFunction<__compar_fn_t>> __compar,
  ) {
    return _qsort(
      __base,
      __nmemb,
      __size,
      __compar,
    );
  }

  late final _qsort_ptr = _lookup<ffi.NativeFunction<_c_qsort>>('qsort');
  late final _dart_qsort _qsort = _qsort_ptr.asFunction<_dart_qsort>();

  int abs(
    int __x,
  ) {
    return _abs(
      __x,
    );
  }

  late final _abs_ptr = _lookup<ffi.NativeFunction<_c_abs>>('abs');
  late final _dart_abs _abs = _abs_ptr.asFunction<_dart_abs>();

  int labs(
    int __x,
  ) {
    return _labs(
      __x,
    );
  }

  late final _labs_ptr = _lookup<ffi.NativeFunction<_c_labs>>('labs');
  late final _dart_labs _labs = _labs_ptr.asFunction<_dart_labs>();

  int llabs(
    int __x,
  ) {
    return _llabs(
      __x,
    );
  }

  late final _llabs_ptr = _lookup<ffi.NativeFunction<_c_llabs>>('llabs');
  late final _dart_llabs _llabs = _llabs_ptr.asFunction<_dart_llabs>();

  div_t div(
    int __numer,
    int __denom,
  ) {
    return _div(
      __numer,
      __denom,
    );
  }

  late final _div_ptr = _lookup<ffi.NativeFunction<_c_div>>('div');
  late final _dart_div _div = _div_ptr.asFunction<_dart_div>();

  ldiv_t ldiv(
    int __numer,
    int __denom,
  ) {
    return _ldiv(
      __numer,
      __denom,
    );
  }

  late final _ldiv_ptr = _lookup<ffi.NativeFunction<_c_ldiv>>('ldiv');
  late final _dart_ldiv _ldiv = _ldiv_ptr.asFunction<_dart_ldiv>();

  lldiv_t lldiv(
    int __numer,
    int __denom,
  ) {
    return _lldiv(
      __numer,
      __denom,
    );
  }

  late final _lldiv_ptr = _lookup<ffi.NativeFunction<_c_lldiv>>('lldiv');
  late final _dart_lldiv _lldiv = _lldiv_ptr.asFunction<_dart_lldiv>();

  ffi.Pointer<ffi.Int8> ecvt(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int32> __decpt,
    ffi.Pointer<ffi.Int32> __sign,
  ) {
    return _ecvt(
      __value,
      __ndigit,
      __decpt,
      __sign,
    );
  }

  late final _ecvt_ptr = _lookup<ffi.NativeFunction<_c_ecvt>>('ecvt');
  late final _dart_ecvt _ecvt = _ecvt_ptr.asFunction<_dart_ecvt>();

  ffi.Pointer<ffi.Int8> fcvt(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int32> __decpt,
    ffi.Pointer<ffi.Int32> __sign,
  ) {
    return _fcvt(
      __value,
      __ndigit,
      __decpt,
      __sign,
    );
  }

  late final _fcvt_ptr = _lookup<ffi.NativeFunction<_c_fcvt>>('fcvt');
  late final _dart_fcvt _fcvt = _fcvt_ptr.asFunction<_dart_fcvt>();

  ffi.Pointer<ffi.Int8> gcvt(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int8> __buf,
  ) {
    return _gcvt(
      __value,
      __ndigit,
      __buf,
    );
  }

  late final _gcvt_ptr = _lookup<ffi.NativeFunction<_c_gcvt>>('gcvt');
  late final _dart_gcvt _gcvt = _gcvt_ptr.asFunction<_dart_gcvt>();

  int ecvt_r(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int32> __decpt,
    ffi.Pointer<ffi.Int32> __sign,
    ffi.Pointer<ffi.Int8> __buf,
    int __len,
  ) {
    return _ecvt_r(
      __value,
      __ndigit,
      __decpt,
      __sign,
      __buf,
      __len,
    );
  }

  late final _ecvt_r_ptr = _lookup<ffi.NativeFunction<_c_ecvt_r>>('ecvt_r');
  late final _dart_ecvt_r _ecvt_r = _ecvt_r_ptr.asFunction<_dart_ecvt_r>();

  int fcvt_r(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int32> __decpt,
    ffi.Pointer<ffi.Int32> __sign,
    ffi.Pointer<ffi.Int8> __buf,
    int __len,
  ) {
    return _fcvt_r(
      __value,
      __ndigit,
      __decpt,
      __sign,
      __buf,
      __len,
    );
  }

  late final _fcvt_r_ptr = _lookup<ffi.NativeFunction<_c_fcvt_r>>('fcvt_r');
  late final _dart_fcvt_r _fcvt_r = _fcvt_r_ptr.asFunction<_dart_fcvt_r>();

  int mblen(
    ffi.Pointer<ffi.Int8> __s,
    int __n,
  ) {
    return _mblen(
      __s,
      __n,
    );
  }

  late final _mblen_ptr = _lookup<ffi.NativeFunction<_c_mblen>>('mblen');
  late final _dart_mblen _mblen = _mblen_ptr.asFunction<_dart_mblen>();

  int mbtowc(
    ffi.Pointer<ffi.Int32> __pwc,
    ffi.Pointer<ffi.Int8> __s,
    int __n,
  ) {
    return _mbtowc(
      __pwc,
      __s,
      __n,
    );
  }

  late final _mbtowc_ptr = _lookup<ffi.NativeFunction<_c_mbtowc>>('mbtowc');
  late final _dart_mbtowc _mbtowc = _mbtowc_ptr.asFunction<_dart_mbtowc>();

  int wctomb(
    ffi.Pointer<ffi.Int8> __s,
    int __wchar,
  ) {
    return _wctomb(
      __s,
      __wchar,
    );
  }

  late final _wctomb_ptr = _lookup<ffi.NativeFunction<_c_wctomb>>('wctomb');
  late final _dart_wctomb _wctomb = _wctomb_ptr.asFunction<_dart_wctomb>();

  int mbstowcs(
    ffi.Pointer<ffi.Int32> __pwcs,
    ffi.Pointer<ffi.Int8> __s,
    int __n,
  ) {
    return _mbstowcs(
      __pwcs,
      __s,
      __n,
    );
  }

  late final _mbstowcs_ptr =
      _lookup<ffi.NativeFunction<_c_mbstowcs>>('mbstowcs');
  late final _dart_mbstowcs _mbstowcs =
      _mbstowcs_ptr.asFunction<_dart_mbstowcs>();

  int wcstombs(
    ffi.Pointer<ffi.Int8> __s,
    ffi.Pointer<ffi.Int32> __pwcs,
    int __n,
  ) {
    return _wcstombs(
      __s,
      __pwcs,
      __n,
    );
  }

  late final _wcstombs_ptr =
      _lookup<ffi.NativeFunction<_c_wcstombs>>('wcstombs');
  late final _dart_wcstombs _wcstombs =
      _wcstombs_ptr.asFunction<_dart_wcstombs>();

  int rpmatch(
    ffi.Pointer<ffi.Int8> __response,
  ) {
    return _rpmatch(
      __response,
    );
  }

  late final _rpmatch_ptr = _lookup<ffi.NativeFunction<_c_rpmatch>>('rpmatch');
  late final _dart_rpmatch _rpmatch = _rpmatch_ptr.asFunction<_dart_rpmatch>();

  int getsubopt(
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __optionp,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __tokens,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __valuep,
  ) {
    return _getsubopt(
      __optionp,
      __tokens,
      __valuep,
    );
  }

  late final _getsubopt_ptr =
      _lookup<ffi.NativeFunction<_c_getsubopt>>('getsubopt');
  late final _dart_getsubopt _getsubopt =
      _getsubopt_ptr.asFunction<_dart_getsubopt>();

  int getloadavg(
    ffi.Pointer<ffi.Double> __loadavg,
    int __nelem,
  ) {
    return _getloadavg(
      __loadavg,
      __nelem,
    );
  }

  late final _getloadavg_ptr =
      _lookup<ffi.NativeFunction<_c_getloadavg>>('getloadavg');
  late final _dart_getloadavg _getloadavg =
      _getloadavg_ptr.asFunction<_dart_getloadavg>();

  /// DECAF_TRUE = -1 so that DECAF_TRUE & x = x
  late final ffi.Pointer<ffi.Uint64> _DECAF_TRUE =
      _lookup<ffi.Uint64>('DECAF_TRUE');

  int get DECAF_TRUE => _DECAF_TRUE.value;

  set DECAF_TRUE(int value) => _DECAF_TRUE.value = value;

  /// DECAF_FALSE = 0 so that DECAF_FALSE & x = 0
  late final ffi.Pointer<ffi.Uint64> _DECAF_FALSE =
      _lookup<ffi.Uint64>('DECAF_FALSE');

  int get DECAF_FALSE => _DECAF_FALSE.value;

  set DECAF_FALSE(int value) => _DECAF_FALSE.value = value;

  /// Overwrite data with zeros.  Uses memset_s if available.
  void decaf_bzero(
    ffi.Pointer<ffi.Void> data,
    int size,
  ) {
    return _decaf_bzero(
      data,
      size,
    );
  }

  late final _decaf_bzero_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_bzero>>('decaf_bzero');
  late final _dart_decaf_bzero _decaf_bzero =
      _decaf_bzero_ptr.asFunction<_dart_decaf_bzero>();

  /// Compare two buffers, returning DECAF_TRUE if they are equal.
  int decaf_memeq(
    ffi.Pointer<ffi.Void> data1,
    ffi.Pointer<ffi.Void> data2,
    int size,
  ) {
    return _decaf_memeq(
      data1,
      data2,
      size,
    );
  }

  late final _decaf_memeq_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_memeq>>('decaf_memeq');
  late final _dart_decaf_memeq _decaf_memeq =
      _decaf_memeq_ptr.asFunction<_dart_decaf_memeq>();

  /// Initialize a SHA-512 context.
  void decaf_sha512_init(
    ffi.Pointer<decaf_sha512_ctx_t> ctx,
  ) {
    return _decaf_sha512_init(
      ctx,
    );
  }

  late final _decaf_sha512_init_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_sha512_init>>('decaf_sha512_init');
  late final _dart_decaf_sha512_init _decaf_sha512_init =
      _decaf_sha512_init_ptr.asFunction<_dart_decaf_sha512_init>();

  /// Update context by hashing part of a message.
  void decaf_sha512_update(
    ffi.Pointer<decaf_sha512_ctx_t> ctx,
    ffi.Pointer<ffi.Uint8> message,
    int message_len,
  ) {
    return _decaf_sha512_update(
      ctx,
      message,
      message_len,
    );
  }

  late final _decaf_sha512_update_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_sha512_update>>(
          'decaf_sha512_update');
  late final _dart_decaf_sha512_update _decaf_sha512_update =
      _decaf_sha512_update_ptr.asFunction<_dart_decaf_sha512_update>();

  /// Finalize context and write out hash.
  /// @param [inout] ctx The context.  Will be destroyed and re-initialized on return.
  /// @param [out] output Place to store the output hash.
  /// @param [in] output_len Length in bytes of the output hash.  Must between 0 and 64, inclusive.
  void decaf_sha512_final(
    ffi.Pointer<decaf_sha512_ctx_t> ctx,
    ffi.Pointer<ffi.Uint8> output,
    int output_len,
  ) {
    return _decaf_sha512_final(
      ctx,
      output,
      output_len,
    );
  }

  late final _decaf_sha512_final_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_sha512_final>>('decaf_sha512_final');
  late final _dart_decaf_sha512_final _decaf_sha512_final =
      _decaf_sha512_final_ptr.asFunction<_dart_decaf_sha512_final>();

  /// Size and alignment of precomputed point tables.
  late final ffi.Pointer<ffi.Uint64> _decaf_448_sizeof_precomputed_s =
      _lookup<ffi.Uint64>('decaf_448_sizeof_precomputed_s');

  int get decaf_448_sizeof_precomputed_s =>
      _decaf_448_sizeof_precomputed_s.value;

  set decaf_448_sizeof_precomputed_s(int value) =>
      _decaf_448_sizeof_precomputed_s.value = value;

  late final ffi.Pointer<ffi.Uint64> _decaf_448_alignof_precomputed_s =
      _lookup<ffi.Uint64>('decaf_448_alignof_precomputed_s');

  int get decaf_448_alignof_precomputed_s =>
      _decaf_448_alignof_precomputed_s.value;

  set decaf_448_alignof_precomputed_s(int value) =>
      _decaf_448_alignof_precomputed_s.value = value;

  /// The scalar 1.
  late final ffi.Pointer<ffi.Pointer<decaf_448_scalar_t>>
      _decaf_448_scalar_one =
      _lookup<ffi.Pointer<decaf_448_scalar_t>>('decaf_448_scalar_one');

  ffi.Pointer<decaf_448_scalar_t> get decaf_448_scalar_one =>
      _decaf_448_scalar_one.value;

  set decaf_448_scalar_one(ffi.Pointer<decaf_448_scalar_t> value) =>
      _decaf_448_scalar_one.value = value;

  /// The scalar 0.
  late final ffi.Pointer<ffi.Pointer<decaf_448_scalar_t>>
      _decaf_448_scalar_zero =
      _lookup<ffi.Pointer<decaf_448_scalar_t>>('decaf_448_scalar_zero');

  ffi.Pointer<decaf_448_scalar_t> get decaf_448_scalar_zero =>
      _decaf_448_scalar_zero.value;

  set decaf_448_scalar_zero(ffi.Pointer<decaf_448_scalar_t> value) =>
      _decaf_448_scalar_zero.value = value;

  /// The identity (zero) point on the curve.
  late final ffi.Pointer<ffi.Pointer<decaf_448_point_t>>
      _decaf_448_point_identity =
      _lookup<ffi.Pointer<decaf_448_point_t>>('decaf_448_point_identity');

  ffi.Pointer<decaf_448_point_t> get decaf_448_point_identity =>
      _decaf_448_point_identity.value;

  set decaf_448_point_identity(ffi.Pointer<decaf_448_point_t> value) =>
      _decaf_448_point_identity.value = value;

  /// An arbitrarily-chosen base point on the curve.
  late final ffi.Pointer<ffi.Pointer<decaf_448_point_t>> _decaf_448_point_base =
      _lookup<ffi.Pointer<decaf_448_point_t>>('decaf_448_point_base');

  ffi.Pointer<decaf_448_point_t> get decaf_448_point_base =>
      _decaf_448_point_base.value;

  set decaf_448_point_base(ffi.Pointer<decaf_448_point_t> value) =>
      _decaf_448_point_base.value = value;

  /// Precomputed table of multiples of the base point on the curve.
  late final ffi.Pointer<ffi.Pointer<decaf_448_precomputed_s>>
      _decaf_448_precomputed_base =
      _lookup<ffi.Pointer<decaf_448_precomputed_s>>(
          'decaf_448_precomputed_base');

  ffi.Pointer<decaf_448_precomputed_s> get decaf_448_precomputed_base =>
      _decaf_448_precomputed_base.value;

  set decaf_448_precomputed_base(ffi.Pointer<decaf_448_precomputed_s> value) =>
      _decaf_448_precomputed_base.value = value;

  /// @brief Read a scalar from wire format or from bytes.
  ///
  /// @param [in] ser Serialized form of a scalar.
  /// @param [out] out Deserialized form.
  ///
  /// @retval DECAF_SUCCESS The scalar was correctly encoded.
  /// @retval DECAF_FAILURE The scalar was greater than the modulus,
  /// and has been reduced modulo that modulus.
  int decaf_448_scalar_decode(
    ffi.Pointer<decaf_448_scalar_t> out,
    ffi.Pointer<ffi.Uint8> ser,
  ) {
    return _decaf_448_scalar_decode(
      out,
      ser,
    );
  }

  late final _decaf_448_scalar_decode_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_scalar_decode>>(
          'decaf_448_scalar_decode');
  late final _dart_decaf_448_scalar_decode _decaf_448_scalar_decode =
      _decaf_448_scalar_decode_ptr.asFunction<_dart_decaf_448_scalar_decode>();

  /// @brief Read a scalar from wire format or from bytes.  Reduces mod
  /// scalar prime.
  ///
  /// @param [in] ser Serialized form of a scalar.
  /// @param [in] ser_len Length of serialized form.
  /// @param [out] out Deserialized form.
  void decaf_448_scalar_decode_long(
    ffi.Pointer<decaf_448_scalar_t> out,
    ffi.Pointer<ffi.Uint8> ser,
    int ser_len,
  ) {
    return _decaf_448_scalar_decode_long(
      out,
      ser,
      ser_len,
    );
  }

  late final _decaf_448_scalar_decode_long_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_scalar_decode_long>>(
          'decaf_448_scalar_decode_long');
  late final _dart_decaf_448_scalar_decode_long _decaf_448_scalar_decode_long =
      _decaf_448_scalar_decode_long_ptr
          .asFunction<_dart_decaf_448_scalar_decode_long>();

  /// @brief Serialize a scalar to wire format.
  ///
  /// @param [out] ser Serialized form of a scalar.
  /// @param [in] s Deserialized scalar.
  void decaf_448_scalar_encode(
    ffi.Pointer<ffi.Uint8> ser,
    ffi.Pointer<decaf_448_scalar_t> s,
  ) {
    return _decaf_448_scalar_encode(
      ser,
      s,
    );
  }

  late final _decaf_448_scalar_encode_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_scalar_encode>>(
          'decaf_448_scalar_encode');
  late final _dart_decaf_448_scalar_encode _decaf_448_scalar_encode =
      _decaf_448_scalar_encode_ptr.asFunction<_dart_decaf_448_scalar_encode>();

  /// @brief Add two scalars.  The scalars may use the same memory.
  /// @param [in] a One scalar.
  /// @param [in] b Another scalar.
  /// @param [out] out a+b.
  void decaf_448_scalar_add(
    ffi.Pointer<decaf_448_scalar_t> out,
    ffi.Pointer<decaf_448_scalar_t> a,
    ffi.Pointer<decaf_448_scalar_t> b,
  ) {
    return _decaf_448_scalar_add(
      out,
      a,
      b,
    );
  }

  late final _decaf_448_scalar_add_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_scalar_add>>(
          'decaf_448_scalar_add');
  late final _dart_decaf_448_scalar_add _decaf_448_scalar_add =
      _decaf_448_scalar_add_ptr.asFunction<_dart_decaf_448_scalar_add>();

  /// @brief Compare two scalars.
  /// @param [in] a One scalar.
  /// @param [in] b Another scalar.
  /// @retval DECAF_TRUE The scalars are equal.
  /// @retval DECAF_FALSE The scalars are not equal.
  int decaf_448_scalar_eq(
    ffi.Pointer<decaf_448_scalar_t> a,
    ffi.Pointer<decaf_448_scalar_t> b,
  ) {
    return _decaf_448_scalar_eq(
      a,
      b,
    );
  }

  late final _decaf_448_scalar_eq_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_scalar_eq>>(
          'decaf_448_scalar_eq');
  late final _dart_decaf_448_scalar_eq _decaf_448_scalar_eq =
      _decaf_448_scalar_eq_ptr.asFunction<_dart_decaf_448_scalar_eq>();

  /// @brief Subtract two scalars.  The scalars may use the same memory.
  /// @param [in] a One scalar.
  /// @param [in] b Another scalar.
  /// @param [out] out a-b.
  void decaf_448_scalar_sub(
    ffi.Pointer<decaf_448_scalar_t> out,
    ffi.Pointer<decaf_448_scalar_t> a,
    ffi.Pointer<decaf_448_scalar_t> b,
  ) {
    return _decaf_448_scalar_sub(
      out,
      a,
      b,
    );
  }

  late final _decaf_448_scalar_sub_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_scalar_sub>>(
          'decaf_448_scalar_sub');
  late final _dart_decaf_448_scalar_sub _decaf_448_scalar_sub =
      _decaf_448_scalar_sub_ptr.asFunction<_dart_decaf_448_scalar_sub>();

  /// @brief Multiply two scalars.  The scalars may use the same memory.
  /// @param [in] a One scalar.
  /// @param [in] b Another scalar.
  /// @param [out] out a*b.
  void decaf_448_scalar_mul(
    ffi.Pointer<decaf_448_scalar_t> out,
    ffi.Pointer<decaf_448_scalar_t> a,
    ffi.Pointer<decaf_448_scalar_t> b,
  ) {
    return _decaf_448_scalar_mul(
      out,
      a,
      b,
    );
  }

  late final _decaf_448_scalar_mul_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_scalar_mul>>(
          'decaf_448_scalar_mul');
  late final _dart_decaf_448_scalar_mul _decaf_448_scalar_mul =
      _decaf_448_scalar_mul_ptr.asFunction<_dart_decaf_448_scalar_mul>();

  /// @brief Halve a scalar.  The scalars may use the same memory.
  /// @param [in] a A scalar.
  /// @param [out] out a/2.
  void decaf_448_scalar_halve(
    ffi.Pointer<decaf_448_scalar_t> out,
    ffi.Pointer<decaf_448_scalar_t> a,
  ) {
    return _decaf_448_scalar_halve(
      out,
      a,
    );
  }

  late final _decaf_448_scalar_halve_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_scalar_halve>>(
          'decaf_448_scalar_halve');
  late final _dart_decaf_448_scalar_halve _decaf_448_scalar_halve =
      _decaf_448_scalar_halve_ptr.asFunction<_dart_decaf_448_scalar_halve>();

  /// @brief Invert a scalar.  When passed zero, return 0.  The input and output may alias.
  /// @param [in] a A scalar.
  /// @param [out] out 1/a.
  /// @return DECAF_SUCCESS The input is nonzero.
  int decaf_448_scalar_invert(
    ffi.Pointer<decaf_448_scalar_t> out,
    ffi.Pointer<decaf_448_scalar_t> a,
  ) {
    return _decaf_448_scalar_invert(
      out,
      a,
    );
  }

  late final _decaf_448_scalar_invert_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_scalar_invert>>(
          'decaf_448_scalar_invert');
  late final _dart_decaf_448_scalar_invert _decaf_448_scalar_invert =
      _decaf_448_scalar_invert_ptr.asFunction<_dart_decaf_448_scalar_invert>();

  /// @brief Set a scalar to an unsigned 64-bit integer.
  /// @param [in] a An integer.
  /// @param [out] out Will become equal to a.
  void decaf_448_scalar_set_unsigned(
    ffi.Pointer<decaf_448_scalar_t> out,
    int a,
  ) {
    return _decaf_448_scalar_set_unsigned(
      out,
      a,
    );
  }

  late final _decaf_448_scalar_set_unsigned_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_scalar_set_unsigned>>(
          'decaf_448_scalar_set_unsigned');
  late final _dart_decaf_448_scalar_set_unsigned
      _decaf_448_scalar_set_unsigned = _decaf_448_scalar_set_unsigned_ptr
          .asFunction<_dart_decaf_448_scalar_set_unsigned>();

  /// @brief Encode a point as a sequence of bytes.
  ///
  /// @param [out] ser The byte representation of the point.
  /// @param [in] pt The point to encode.
  void decaf_448_point_encode(
    ffi.Pointer<ffi.Uint8> ser,
    ffi.Pointer<decaf_448_point_t> pt,
  ) {
    return _decaf_448_point_encode(
      ser,
      pt,
    );
  }

  late final _decaf_448_point_encode_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_point_encode>>(
          'decaf_448_point_encode');
  late final _dart_decaf_448_point_encode _decaf_448_point_encode =
      _decaf_448_point_encode_ptr.asFunction<_dart_decaf_448_point_encode>();

  /// @brief Decode a point from a sequence of bytes.
  ///
  /// Every point has a unique encoding, so not every
  /// sequence of bytes is a valid encoding.  If an invalid
  /// encoding is given, the output is undefined.
  ///
  /// @param [out] pt The decoded point.
  /// @param [in] ser The serialized version of the point.
  /// @param [in] allow_identity DECAF_TRUE if the identity is a legal input.
  /// @retval DECAF_SUCCESS The decoding succeeded.
  /// @retval DECAF_FAILURE The decoding didn't succeed, because
  /// ser does not represent a point.
  int decaf_448_point_decode(
    ffi.Pointer<decaf_448_point_t> pt,
    ffi.Pointer<ffi.Uint8> ser,
    int allow_identity,
  ) {
    return _decaf_448_point_decode(
      pt,
      ser,
      allow_identity,
    );
  }

  late final _decaf_448_point_decode_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_point_decode>>(
          'decaf_448_point_decode');
  late final _dart_decaf_448_point_decode _decaf_448_point_decode =
      _decaf_448_point_decode_ptr.asFunction<_dart_decaf_448_point_decode>();

  /// @brief Test whether two points are equal.  If yes, return
  /// DECAF_TRUE, else return DECAF_FALSE.
  ///
  /// @param [in] a A point.
  /// @param [in] b Another point.
  /// @retval DECAF_TRUE The points are equal.
  /// @retval DECAF_FALSE The points are not equal.
  int decaf_448_point_eq(
    ffi.Pointer<decaf_448_point_t> a,
    ffi.Pointer<decaf_448_point_t> b,
  ) {
    return _decaf_448_point_eq(
      a,
      b,
    );
  }

  late final _decaf_448_point_eq_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_point_eq>>('decaf_448_point_eq');
  late final _dart_decaf_448_point_eq _decaf_448_point_eq =
      _decaf_448_point_eq_ptr.asFunction<_dart_decaf_448_point_eq>();

  /// @brief Add two points to produce a third point.  The
  /// input points and output point can be pointers to the same
  /// memory.
  ///
  /// @param [out] sum The sum a+b.
  /// @param [in] a An addend.
  /// @param [in] b An addend.
  void decaf_448_point_add(
    ffi.Pointer<decaf_448_point_t> sum,
    ffi.Pointer<decaf_448_point_t> a,
    ffi.Pointer<decaf_448_point_t> b,
  ) {
    return _decaf_448_point_add(
      sum,
      a,
      b,
    );
  }

  late final _decaf_448_point_add_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_point_add>>(
          'decaf_448_point_add');
  late final _dart_decaf_448_point_add _decaf_448_point_add =
      _decaf_448_point_add_ptr.asFunction<_dart_decaf_448_point_add>();

  /// @brief Double a point.  Equivalent to
  /// decaf_448_point_add(two_a,a,a), but potentially faster.
  ///
  /// @param [out] two_a The sum a+a.
  /// @param [in] a A point.
  void decaf_448_point_double(
    ffi.Pointer<decaf_448_point_t> two_a,
    ffi.Pointer<decaf_448_point_t> a,
  ) {
    return _decaf_448_point_double(
      two_a,
      a,
    );
  }

  late final _decaf_448_point_double_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_point_double>>(
          'decaf_448_point_double');
  late final _dart_decaf_448_point_double _decaf_448_point_double =
      _decaf_448_point_double_ptr.asFunction<_dart_decaf_448_point_double>();

  /// @brief Subtract two points to produce a third point.  The
  /// input points and output point can be pointers to the same
  /// memory.
  ///
  /// @param [out] diff The difference a-b.
  /// @param [in] a The minuend.
  /// @param [in] b The subtrahend.
  void decaf_448_point_sub(
    ffi.Pointer<decaf_448_point_t> diff,
    ffi.Pointer<decaf_448_point_t> a,
    ffi.Pointer<decaf_448_point_t> b,
  ) {
    return _decaf_448_point_sub(
      diff,
      a,
      b,
    );
  }

  late final _decaf_448_point_sub_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_point_sub>>(
          'decaf_448_point_sub');
  late final _dart_decaf_448_point_sub _decaf_448_point_sub =
      _decaf_448_point_sub_ptr.asFunction<_dart_decaf_448_point_sub>();

  /// @brief Negate a point to produce another point.  The input
  /// and output points can use the same memory.
  ///
  /// @param [out] nega The negated input point
  /// @param [in] a The input point.
  void decaf_448_point_negate(
    ffi.Pointer<decaf_448_point_t> nega,
    ffi.Pointer<decaf_448_point_t> a,
  ) {
    return _decaf_448_point_negate(
      nega,
      a,
    );
  }

  late final _decaf_448_point_negate_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_point_negate>>(
          'decaf_448_point_negate');
  late final _dart_decaf_448_point_negate _decaf_448_point_negate =
      _decaf_448_point_negate_ptr.asFunction<_dart_decaf_448_point_negate>();

  /// @brief Multiply a base point by a scalar: scaled = scalar*base.
  ///
  /// @param [out] scaled The scaled point base*scalar
  /// @param [in] base The point to be scaled.
  /// @param [in] scalar The scalar to multiply by.
  void decaf_448_point_scalarmul(
    ffi.Pointer<decaf_448_point_t> scaled,
    ffi.Pointer<decaf_448_point_t> base,
    ffi.Pointer<decaf_448_scalar_t> scalar,
  ) {
    return _decaf_448_point_scalarmul(
      scaled,
      base,
      scalar,
    );
  }

  late final _decaf_448_point_scalarmul_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_point_scalarmul>>(
          'decaf_448_point_scalarmul');
  late final _dart_decaf_448_point_scalarmul _decaf_448_point_scalarmul =
      _decaf_448_point_scalarmul_ptr
          .asFunction<_dart_decaf_448_point_scalarmul>();

  /// @brief Multiply a base point by a scalar: scaled = scalar*base.
  /// This function operates directly on serialized forms.
  ///
  /// @warning This function is experimental.  It may not be supported
  /// long-term.
  ///
  /// @param [out] scaled The scaled point base*scalar
  /// @param [in] base The point to be scaled.
  /// @param [in] scalar The scalar to multiply by.
  /// @param [in] allow_identity Allow the input to be the identity.
  /// @param [in] short_circuit Allow a fast return if the input is illegal.
  ///
  /// @retval DECAF_SUCCESS The scalarmul succeeded.
  /// @retval DECAF_FAILURE The scalarmul didn't succeed, because
  /// base does not represent a point.
  int decaf_448_direct_scalarmul(
    ffi.Pointer<ffi.Uint8> scaled,
    ffi.Pointer<ffi.Uint8> base,
    ffi.Pointer<decaf_448_scalar_t> scalar,
    int allow_identity,
    int short_circuit,
  ) {
    return _decaf_448_direct_scalarmul(
      scaled,
      base,
      scalar,
      allow_identity,
      short_circuit,
    );
  }

  late final _decaf_448_direct_scalarmul_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_direct_scalarmul>>(
          'decaf_448_direct_scalarmul');
  late final _dart_decaf_448_direct_scalarmul _decaf_448_direct_scalarmul =
      _decaf_448_direct_scalarmul_ptr
          .asFunction<_dart_decaf_448_direct_scalarmul>();

  /// @brief RFC 7748 Diffie-Hellman scalarmul, used to compute shared secrets.
  /// This function uses a different (non-Decaf) encoding.
  ///
  /// @param [out] shared The shared secret base*scalar
  /// @param [in] base The other party's public key, used as the base of the scalarmul.
  /// @param [in] scalar The private scalar to multiply by.
  ///
  /// @retval DECAF_SUCCESS The scalarmul succeeded.
  /// @retval DECAF_FAILURE The scalarmul didn't succeed, because the base
  /// point is in a small subgroup.
  int decaf_x448(
    ffi.Pointer<ffi.Uint8> shared,
    ffi.Pointer<ffi.Uint8> base,
    ffi.Pointer<ffi.Uint8> scalar,
  ) {
    return _decaf_x448(
      shared,
      base,
      scalar,
    );
  }

  late final _decaf_x448_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_x448>>('decaf_x448');
  late final _dart_decaf_x448 _decaf_x448 =
      _decaf_x448_ptr.asFunction<_dart_decaf_x448>();

  /// @brief Multiply a point by DECAF_X448_ENCODE_RATIO,
  /// then encode it like RFC 7748.
  ///
  /// This function is mainly used internally, but is exported in case
  /// it will be useful.
  ///
  /// The ratio is necessary because the internal representation doesn't
  /// track the cofactor information, so on output we must clear the cofactor.
  /// This would multiply by the cofactor, but in fact internally libdecaf's
  /// points are always even, so it multiplies by half the cofactor instead.
  ///
  /// As it happens, this aligns with the base point definitions; that is,
  /// if you pass the Decaf/Ristretto base point to this function, the result
  /// will be DECAF_X448_ENCODE_RATIO times the X448
  /// base point.
  ///
  /// @param [out] out The scaled and encoded point.
  /// @param [in] p The point to be scaled and encoded.
  void decaf_448_point_mul_by_ratio_and_encode_like_x448(
    ffi.Pointer<ffi.Uint8> out,
    ffi.Pointer<decaf_448_point_t> p,
  ) {
    return _decaf_448_point_mul_by_ratio_and_encode_like_x448(
      out,
      p,
    );
  }

  late final _decaf_448_point_mul_by_ratio_and_encode_like_x448_ptr = _lookup<
          ffi.NativeFunction<
              _c_decaf_448_point_mul_by_ratio_and_encode_like_x448>>(
      'decaf_448_point_mul_by_ratio_and_encode_like_x448');
  late final _dart_decaf_448_point_mul_by_ratio_and_encode_like_x448
      _decaf_448_point_mul_by_ratio_and_encode_like_x448 =
      _decaf_448_point_mul_by_ratio_and_encode_like_x448_ptr.asFunction<
          _dart_decaf_448_point_mul_by_ratio_and_encode_like_x448>();

  late final ffi.Pointer<ffi.Pointer<ffi.Uint8>> _decaf_x448_base_point =
      _lookup<ffi.Pointer<ffi.Uint8>>('decaf_x448_base_point');

  ffi.Pointer<ffi.Uint8> get decaf_x448_base_point =>
      _decaf_x448_base_point.value;

  set decaf_x448_base_point(ffi.Pointer<ffi.Uint8> value) =>
      _decaf_x448_base_point.value = value;

  /// @brief RFC 7748 Diffie-Hellman base point scalarmul.  This function uses
  /// a different (non-Decaf) encoding.
  ///
  /// @deprecated Renamed to decaf_x448_derive_public_key.
  /// I have no particular timeline for removing this name.
  ///
  /// @param [out] out The public key base*scalar.
  /// @param [in] scalar The private scalar.
  void decaf_x448_generate_key(
    ffi.Pointer<ffi.Uint8> out,
    ffi.Pointer<ffi.Uint8> scalar,
  ) {
    return _decaf_x448_generate_key(
      out,
      scalar,
    );
  }

  late final _decaf_x448_generate_key_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_x448_generate_key>>(
          'decaf_x448_generate_key');
  late final _dart_decaf_x448_generate_key _decaf_x448_generate_key =
      _decaf_x448_generate_key_ptr.asFunction<_dart_decaf_x448_generate_key>();

  /// @brief RFC 7748 Diffie-Hellman base point scalarmul.  This function uses
  /// a different (non-Decaf) encoding.
  ///
  /// Does exactly the same thing as decaf_x448_generate_key,
  /// but has a better name.
  ///
  /// @param [out] out The public key base*scalar
  /// @param [in] scalar The private scalar.
  void decaf_x448_derive_public_key(
    ffi.Pointer<ffi.Uint8> out,
    ffi.Pointer<ffi.Uint8> scalar,
  ) {
    return _decaf_x448_derive_public_key(
      out,
      scalar,
    );
  }

  late final _decaf_x448_derive_public_key_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_x448_derive_public_key>>(
          'decaf_x448_derive_public_key');
  late final _dart_decaf_x448_derive_public_key _decaf_x448_derive_public_key =
      _decaf_x448_derive_public_key_ptr
          .asFunction<_dart_decaf_x448_derive_public_key>();

  /// @brief Precompute a table for fast scalar multiplication.
  /// Some implementations do not include precomputed points; for
  /// those implementations, this implementation simply copies the
  /// point.
  ///
  /// @param [out] a A precomputed table of multiples of the point.
  /// @param [in] b Any point.
  void decaf_448_precompute(
    ffi.Pointer<decaf_448_precomputed_s> a,
    ffi.Pointer<decaf_448_point_t> b,
  ) {
    return _decaf_448_precompute(
      a,
      b,
    );
  }

  late final _decaf_448_precompute_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_precompute>>(
          'decaf_448_precompute');
  late final _dart_decaf_448_precompute _decaf_448_precompute =
      _decaf_448_precompute_ptr.asFunction<_dart_decaf_448_precompute>();

  /// @brief Multiply a precomputed base point by a scalar:
  /// scaled = scalar*base.
  /// Some implementations do not include precomputed points; for
  /// those implementations, this function is the same as
  /// decaf_448_point_scalarmul
  ///
  /// @param [out] scaled The scaled point base*scalar
  /// @param [in] base The point to be scaled.
  /// @param [in] scalar The scalar to multiply by.
  void decaf_448_precomputed_scalarmul(
    ffi.Pointer<decaf_448_point_t> scaled,
    ffi.Pointer<decaf_448_precomputed_s> base,
    ffi.Pointer<decaf_448_scalar_t> scalar,
  ) {
    return _decaf_448_precomputed_scalarmul(
      scaled,
      base,
      scalar,
    );
  }

  late final _decaf_448_precomputed_scalarmul_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_precomputed_scalarmul>>(
          'decaf_448_precomputed_scalarmul');
  late final _dart_decaf_448_precomputed_scalarmul
      _decaf_448_precomputed_scalarmul = _decaf_448_precomputed_scalarmul_ptr
          .asFunction<_dart_decaf_448_precomputed_scalarmul>();

  /// @brief Multiply two base points by two scalars:
  /// scaled = scalar1*base1 + scalar2*base2.
  ///
  /// Equivalent to two calls to decaf_448_point_scalarmul, but may be
  /// faster.
  ///
  /// @param [out] combo The linear combination scalar1*base1 + scalar2*base2.
  /// @param [in] base1 A first point to be scaled.
  /// @param [in] scalar1 A first scalar to multiply by.
  /// @param [in] base2 A second point to be scaled.
  /// @param [in] scalar2 A second scalar to multiply by.
  void decaf_448_point_double_scalarmul(
    ffi.Pointer<decaf_448_point_t> combo,
    ffi.Pointer<decaf_448_point_t> base1,
    ffi.Pointer<decaf_448_scalar_t> scalar1,
    ffi.Pointer<decaf_448_point_t> base2,
    ffi.Pointer<decaf_448_scalar_t> scalar2,
  ) {
    return _decaf_448_point_double_scalarmul(
      combo,
      base1,
      scalar1,
      base2,
      scalar2,
    );
  }

  late final _decaf_448_point_double_scalarmul_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_point_double_scalarmul>>(
          'decaf_448_point_double_scalarmul');
  late final _dart_decaf_448_point_double_scalarmul
      _decaf_448_point_double_scalarmul = _decaf_448_point_double_scalarmul_ptr
          .asFunction<_dart_decaf_448_point_double_scalarmul>();

  /// Multiply one base point by two scalars:
  ///
  /// a1 = scalar1 * base
  /// a2 = scalar2 * base
  ///
  /// Equivalent to two calls to decaf_448_point_scalarmul, but may be
  /// faster.
  ///
  /// @param [out] a1 The first multiple.  It may be the same as the input point.
  /// @param [out] a2 The second multiple.  It may be the same as the input point.
  /// @param [in] base1 A point to be scaled.
  /// @param [in] scalar1 A first scalar to multiply by.
  /// @param [in] scalar2 A second scalar to multiply by.
  void decaf_448_point_dual_scalarmul(
    ffi.Pointer<decaf_448_point_t> a1,
    ffi.Pointer<decaf_448_point_t> a2,
    ffi.Pointer<decaf_448_point_t> base1,
    ffi.Pointer<decaf_448_scalar_t> scalar1,
    ffi.Pointer<decaf_448_scalar_t> scalar2,
  ) {
    return _decaf_448_point_dual_scalarmul(
      a1,
      a2,
      base1,
      scalar1,
      scalar2,
    );
  }

  late final _decaf_448_point_dual_scalarmul_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_point_dual_scalarmul>>(
          'decaf_448_point_dual_scalarmul');
  late final _dart_decaf_448_point_dual_scalarmul
      _decaf_448_point_dual_scalarmul = _decaf_448_point_dual_scalarmul_ptr
          .asFunction<_dart_decaf_448_point_dual_scalarmul>();

  /// @brief Multiply two base points by two scalars:
  /// scaled = scalar1*decaf_448_point_base + scalar2*base2.
  ///
  /// Otherwise equivalent to decaf_448_point_double_scalarmul, but may be
  /// faster at the expense of being variable time.
  ///
  /// @param [out] combo The linear combination scalar1*base + scalar2*base2.
  /// @param [in] scalar1 A first scalar to multiply by.
  /// @param [in] base2 A second point to be scaled.
  /// @param [in] scalar2 A second scalar to multiply by.
  ///
  /// @warning: This function takes variable time, and may leak the scalars
  /// used.  It is designed for signature verification.
  void decaf_448_base_double_scalarmul_non_secret(
    ffi.Pointer<decaf_448_point_t> combo,
    ffi.Pointer<decaf_448_scalar_t> scalar1,
    ffi.Pointer<decaf_448_point_t> base2,
    ffi.Pointer<decaf_448_scalar_t> scalar2,
  ) {
    return _decaf_448_base_double_scalarmul_non_secret(
      combo,
      scalar1,
      base2,
      scalar2,
    );
  }

  late final _decaf_448_base_double_scalarmul_non_secret_ptr = _lookup<
          ffi.NativeFunction<_c_decaf_448_base_double_scalarmul_non_secret>>(
      'decaf_448_base_double_scalarmul_non_secret');
  late final _dart_decaf_448_base_double_scalarmul_non_secret
      _decaf_448_base_double_scalarmul_non_secret =
      _decaf_448_base_double_scalarmul_non_secret_ptr
          .asFunction<_dart_decaf_448_base_double_scalarmul_non_secret>();

  /// @brief Constant-time decision between two points.  If pick_b
  /// is zero, out = a; else out = b.
  ///
  /// @param [out] out The output.  It may be the same as either input.
  /// @param [in] a Any point.
  /// @param [in] b Any point.
  /// @param [in] pick_b If nonzero, choose point b.
  void decaf_448_point_cond_sel(
    ffi.Pointer<decaf_448_point_t> out,
    ffi.Pointer<decaf_448_point_t> a,
    ffi.Pointer<decaf_448_point_t> b,
    int pick_b,
  ) {
    return _decaf_448_point_cond_sel(
      out,
      a,
      b,
      pick_b,
    );
  }

  late final _decaf_448_point_cond_sel_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_point_cond_sel>>(
          'decaf_448_point_cond_sel');
  late final _dart_decaf_448_point_cond_sel _decaf_448_point_cond_sel =
      _decaf_448_point_cond_sel_ptr
          .asFunction<_dart_decaf_448_point_cond_sel>();

  /// @brief Constant-time decision between two scalars.  If pick_b
  /// is zero, out = a; else out = b.
  ///
  /// @param [out] out The output.  It may be the same as either input.
  /// @param [in] a Any scalar.
  /// @param [in] b Any scalar.
  /// @param [in] pick_b If nonzero, choose scalar b.
  void decaf_448_scalar_cond_sel(
    ffi.Pointer<decaf_448_scalar_t> out,
    ffi.Pointer<decaf_448_scalar_t> a,
    ffi.Pointer<decaf_448_scalar_t> b,
    int pick_b,
  ) {
    return _decaf_448_scalar_cond_sel(
      out,
      a,
      b,
      pick_b,
    );
  }

  late final _decaf_448_scalar_cond_sel_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_scalar_cond_sel>>(
          'decaf_448_scalar_cond_sel');
  late final _dart_decaf_448_scalar_cond_sel _decaf_448_scalar_cond_sel =
      _decaf_448_scalar_cond_sel_ptr
          .asFunction<_dart_decaf_448_scalar_cond_sel>();

  /// @brief Test that a point is valid, for debugging purposes.
  ///
  /// @param [in] to_test The point to test.
  /// @retval DECAF_TRUE The point is valid.
  /// @retval DECAF_FALSE The point is invalid.
  int decaf_448_point_valid(
    ffi.Pointer<decaf_448_point_t> to_test,
  ) {
    return _decaf_448_point_valid(
      to_test,
    );
  }

  late final _decaf_448_point_valid_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_point_valid>>(
          'decaf_448_point_valid');
  late final _dart_decaf_448_point_valid _decaf_448_point_valid =
      _decaf_448_point_valid_ptr.asFunction<_dart_decaf_448_point_valid>();

  /// @brief Torque a point, for debugging purposes.  The output
  /// will be equal to the input.
  ///
  /// @param [out] q The point to torque.
  /// @param [in] p The point to torque.
  void decaf_448_point_debugging_torque(
    ffi.Pointer<decaf_448_point_t> q,
    ffi.Pointer<decaf_448_point_t> p,
  ) {
    return _decaf_448_point_debugging_torque(
      q,
      p,
    );
  }

  late final _decaf_448_point_debugging_torque_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_point_debugging_torque>>(
          'decaf_448_point_debugging_torque');
  late final _dart_decaf_448_point_debugging_torque
      _decaf_448_point_debugging_torque = _decaf_448_point_debugging_torque_ptr
          .asFunction<_dart_decaf_448_point_debugging_torque>();

  /// @brief Projectively scale a point, for debugging purposes.
  /// The output will be equal to the input, and will be valid
  /// even if the factor is zero.
  ///
  /// @param [out] q The point to scale.
  /// @param [in] p The point to scale.
  /// @param [in] factor Serialized GF factor to scale.
  void decaf_448_point_debugging_pscale(
    ffi.Pointer<decaf_448_point_t> q,
    ffi.Pointer<decaf_448_point_t> p,
    ffi.Pointer<ffi.Uint8> factor,
  ) {
    return _decaf_448_point_debugging_pscale(
      q,
      p,
      factor,
    );
  }

  late final _decaf_448_point_debugging_pscale_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_point_debugging_pscale>>(
          'decaf_448_point_debugging_pscale');
  late final _dart_decaf_448_point_debugging_pscale
      _decaf_448_point_debugging_pscale = _decaf_448_point_debugging_pscale_ptr
          .asFunction<_dart_decaf_448_point_debugging_pscale>();

  /// @brief Almost-Elligator-like hash to curve.
  ///
  /// Call this function with the output of a hash to make a hash to the curve.
  ///
  /// This function runs Elligator2 on the decaf_448 Jacobi quartic model.  It then
  /// uses the isogeny to put the result in twisted Edwards form.  As a result,
  /// it is safe (cannot produce points of order 4), and would be compatible with
  /// hypothetical other implementations of Decaf using a Montgomery or untwisted
  /// Edwards model.
  ///
  /// Unlike Elligator, this function may be up to 4:1 on [0,(p-1)/2]:
  /// A factor of 2 due to the isogeny.
  /// A factor of 2 because we quotient out the 2-torsion.
  ///
  /// This makes it about 8:1 overall, or 16:1 overall on curves with cofactor 8.
  ///
  /// Negating the input (mod q) results in the same point.  Inverting the input
  /// (mod q) results in the negative point.  This is the same as Elligator.
  ///
  /// This function isn't quite indifferentiable from a random oracle.
  /// However, it is suitable for many protocols, including SPEKE and SPAKE2 EE.
  /// Furthermore, calling it twice with independent seeds and adding the results
  /// is indifferentiable from a random oracle.
  ///
  /// @param [in] hashed_data Output of some hash function.
  /// @param [out] pt The data hashed to the curve.
  void decaf_448_point_from_hash_nonuniform(
    ffi.Pointer<decaf_448_point_t> pt,
    ffi.Pointer<ffi.Uint8> hashed_data,
  ) {
    return _decaf_448_point_from_hash_nonuniform(
      pt,
      hashed_data,
    );
  }

  late final _decaf_448_point_from_hash_nonuniform_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_point_from_hash_nonuniform>>(
          'decaf_448_point_from_hash_nonuniform');
  late final _dart_decaf_448_point_from_hash_nonuniform
      _decaf_448_point_from_hash_nonuniform =
      _decaf_448_point_from_hash_nonuniform_ptr
          .asFunction<_dart_decaf_448_point_from_hash_nonuniform>();

  /// @brief Indifferentiable hash function encoding to curve.
  ///
  /// Equivalent to calling decaf_448_point_from_hash_nonuniform twice and adding.
  ///
  /// @param [in] hashed_data Output of some hash function.
  /// @param [out] pt The data hashed to the curve.
  void decaf_448_point_from_hash_uniform(
    ffi.Pointer<decaf_448_point_t> pt,
    ffi.Pointer<ffi.Uint8> hashed_data,
  ) {
    return _decaf_448_point_from_hash_uniform(
      pt,
      hashed_data,
    );
  }

  late final _decaf_448_point_from_hash_uniform_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_point_from_hash_uniform>>(
          'decaf_448_point_from_hash_uniform');
  late final _dart_decaf_448_point_from_hash_uniform
      _decaf_448_point_from_hash_uniform =
      _decaf_448_point_from_hash_uniform_ptr
          .asFunction<_dart_decaf_448_point_from_hash_uniform>();

  /// @brief Inverse of elligator-like hash to curve.
  ///
  /// This function writes to the buffer, to make it so that
  /// decaf_448_point_from_hash_nonuniform(buffer) = pt if
  /// possible.  Since there may be multiple preimages, the
  /// "which" parameter chooses between them.  To ensure uniform
  /// inverse sampling, this function succeeds or fails
  /// independently for different "which" values.
  ///
  /// This function isn't guaranteed to find every possible
  /// preimage, but it finds all except a small finite number.
  /// In particular, when the number of bits in the modulus isn't
  /// a multiple of 8 (i.e. for curve25519), it sets the high bits
  /// independently, which enables the generated data to be uniform.
  /// But it doesn't add p, so you'll never get exactly p from this
  /// function.  This might change in the future, especially if
  /// we ever support eg Brainpool curves, where this could cause
  /// real nonuniformity.
  ///
  /// @param [out] recovered_hash Encoded data.
  /// @param [in] pt The point to encode.
  /// @param [in] which A value determining which inverse point
  /// to return.
  ///
  /// @retval DECAF_SUCCESS The inverse succeeded.
  /// @retval DECAF_FAILURE The inverse failed.
  int decaf_448_invert_elligator_nonuniform(
    ffi.Pointer<ffi.Uint8> recovered_hash,
    ffi.Pointer<decaf_448_point_t> pt,
    int which,
  ) {
    return _decaf_448_invert_elligator_nonuniform(
      recovered_hash,
      pt,
      which,
    );
  }

  late final _decaf_448_invert_elligator_nonuniform_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_invert_elligator_nonuniform>>(
          'decaf_448_invert_elligator_nonuniform');
  late final _dart_decaf_448_invert_elligator_nonuniform
      _decaf_448_invert_elligator_nonuniform =
      _decaf_448_invert_elligator_nonuniform_ptr
          .asFunction<_dart_decaf_448_invert_elligator_nonuniform>();

  /// @brief Inverse of elligator-like hash to curve.
  ///
  /// This function writes to the buffer, to make it so that
  /// decaf_448_point_from_hash_uniform(buffer) = pt if
  /// possible.  Since there may be multiple preimages, the
  /// "which" parameter chooses between them.  To ensure uniform
  /// inverse sampling, this function succeeds or fails
  /// independently for different "which" values.
  ///
  /// @param [out] recovered_hash Encoded data.
  /// @param [in] pt The point to encode.
  /// @param [in] which A value determining which inverse point
  /// to return.
  ///
  /// @retval DECAF_SUCCESS The inverse succeeded.
  /// @retval DECAF_FAILURE The inverse failed.
  int decaf_448_invert_elligator_uniform(
    ffi.Pointer<ffi.Uint8> recovered_hash,
    ffi.Pointer<decaf_448_point_t> pt,
    int which,
  ) {
    return _decaf_448_invert_elligator_uniform(
      recovered_hash,
      pt,
      which,
    );
  }

  late final _decaf_448_invert_elligator_uniform_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_invert_elligator_uniform>>(
          'decaf_448_invert_elligator_uniform');
  late final _dart_decaf_448_invert_elligator_uniform
      _decaf_448_invert_elligator_uniform =
      _decaf_448_invert_elligator_uniform_ptr
          .asFunction<_dart_decaf_448_invert_elligator_uniform>();

  /// Securely erase a scalar.
  void decaf_448_scalar_destroy(
    ffi.Pointer<decaf_448_scalar_t> scalar,
  ) {
    return _decaf_448_scalar_destroy(
      scalar,
    );
  }

  late final _decaf_448_scalar_destroy_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_scalar_destroy>>(
          'decaf_448_scalar_destroy');
  late final _dart_decaf_448_scalar_destroy _decaf_448_scalar_destroy =
      _decaf_448_scalar_destroy_ptr
          .asFunction<_dart_decaf_448_scalar_destroy>();

  /// Securely erase a point by overwriting it with zeros.
  /// @warning This causes the point object to become invalid.
  void decaf_448_point_destroy(
    ffi.Pointer<decaf_448_point_t> point,
  ) {
    return _decaf_448_point_destroy(
      point,
    );
  }

  late final _decaf_448_point_destroy_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_point_destroy>>(
          'decaf_448_point_destroy');
  late final _dart_decaf_448_point_destroy _decaf_448_point_destroy =
      _decaf_448_point_destroy_ptr.asFunction<_dart_decaf_448_point_destroy>();

  /// Securely erase a precomputed table by overwriting it with zeros.
  /// @warning This causes the table object to become invalid.
  void decaf_448_precomputed_destroy(
    ffi.Pointer<decaf_448_precomputed_s> pre,
  ) {
    return _decaf_448_precomputed_destroy(
      pre,
    );
  }

  late final _decaf_448_precomputed_destroy_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_448_precomputed_destroy>>(
          'decaf_448_precomputed_destroy');
  late final _dart_decaf_448_precomputed_destroy
      _decaf_448_precomputed_destroy = _decaf_448_precomputed_destroy_ptr
          .asFunction<_dart_decaf_448_precomputed_destroy>();

  /// Size and alignment of precomputed point tables.
  late final ffi.Pointer<ffi.Uint64> _decaf_255_sizeof_precomputed_s =
      _lookup<ffi.Uint64>('decaf_255_sizeof_precomputed_s');

  int get decaf_255_sizeof_precomputed_s =>
      _decaf_255_sizeof_precomputed_s.value;

  set decaf_255_sizeof_precomputed_s(int value) =>
      _decaf_255_sizeof_precomputed_s.value = value;

  late final ffi.Pointer<ffi.Uint64> _decaf_255_alignof_precomputed_s =
      _lookup<ffi.Uint64>('decaf_255_alignof_precomputed_s');

  int get decaf_255_alignof_precomputed_s =>
      _decaf_255_alignof_precomputed_s.value;

  set decaf_255_alignof_precomputed_s(int value) =>
      _decaf_255_alignof_precomputed_s.value = value;

  /// The scalar 1.
  late final ffi.Pointer<ffi.Pointer<decaf_255_scalar_t>>
      _decaf_255_scalar_one =
      _lookup<ffi.Pointer<decaf_255_scalar_t>>('decaf_255_scalar_one');

  ffi.Pointer<decaf_255_scalar_t> get decaf_255_scalar_one =>
      _decaf_255_scalar_one.value;

  set decaf_255_scalar_one(ffi.Pointer<decaf_255_scalar_t> value) =>
      _decaf_255_scalar_one.value = value;

  /// The scalar 0.
  late final ffi.Pointer<ffi.Pointer<decaf_255_scalar_t>>
      _decaf_255_scalar_zero =
      _lookup<ffi.Pointer<decaf_255_scalar_t>>('decaf_255_scalar_zero');

  ffi.Pointer<decaf_255_scalar_t> get decaf_255_scalar_zero =>
      _decaf_255_scalar_zero.value;

  set decaf_255_scalar_zero(ffi.Pointer<decaf_255_scalar_t> value) =>
      _decaf_255_scalar_zero.value = value;

  /// The identity (zero) point on the curve.
  late final ffi.Pointer<ffi.Pointer<decaf_255_point_t>>
      _decaf_255_point_identity =
      _lookup<ffi.Pointer<decaf_255_point_t>>('decaf_255_point_identity');

  ffi.Pointer<decaf_255_point_t> get decaf_255_point_identity =>
      _decaf_255_point_identity.value;

  set decaf_255_point_identity(ffi.Pointer<decaf_255_point_t> value) =>
      _decaf_255_point_identity.value = value;

  /// An arbitrarily-chosen base point on the curve.
  late final ffi.Pointer<ffi.Pointer<decaf_255_point_t>> _decaf_255_point_base =
      _lookup<ffi.Pointer<decaf_255_point_t>>('decaf_255_point_base');

  ffi.Pointer<decaf_255_point_t> get decaf_255_point_base =>
      _decaf_255_point_base.value;

  set decaf_255_point_base(ffi.Pointer<decaf_255_point_t> value) =>
      _decaf_255_point_base.value = value;

  /// Precomputed table of multiples of the base point on the curve.
  late final ffi.Pointer<ffi.Pointer<decaf_255_precomputed_s>>
      _decaf_255_precomputed_base =
      _lookup<ffi.Pointer<decaf_255_precomputed_s>>(
          'decaf_255_precomputed_base');

  ffi.Pointer<decaf_255_precomputed_s> get decaf_255_precomputed_base =>
      _decaf_255_precomputed_base.value;

  set decaf_255_precomputed_base(ffi.Pointer<decaf_255_precomputed_s> value) =>
      _decaf_255_precomputed_base.value = value;

  /// @brief Read a scalar from wire format or from bytes.
  ///
  /// @param [in] ser Serialized form of a scalar.
  /// @param [out] out Deserialized form.
  ///
  /// @retval DECAF_SUCCESS The scalar was correctly encoded.
  /// @retval DECAF_FAILURE The scalar was greater than the modulus,
  /// and has been reduced modulo that modulus.
  int decaf_255_scalar_decode(
    ffi.Pointer<decaf_255_scalar_t> out,
    ffi.Pointer<ffi.Uint8> ser,
  ) {
    return _decaf_255_scalar_decode(
      out,
      ser,
    );
  }

  late final _decaf_255_scalar_decode_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_scalar_decode>>(
          'decaf_255_scalar_decode');
  late final _dart_decaf_255_scalar_decode _decaf_255_scalar_decode =
      _decaf_255_scalar_decode_ptr.asFunction<_dart_decaf_255_scalar_decode>();

  /// @brief Read a scalar from wire format or from bytes.  Reduces mod
  /// scalar prime.
  ///
  /// @param [in] ser Serialized form of a scalar.
  /// @param [in] ser_len Length of serialized form.
  /// @param [out] out Deserialized form.
  void decaf_255_scalar_decode_long(
    ffi.Pointer<decaf_255_scalar_t> out,
    ffi.Pointer<ffi.Uint8> ser,
    int ser_len,
  ) {
    return _decaf_255_scalar_decode_long(
      out,
      ser,
      ser_len,
    );
  }

  late final _decaf_255_scalar_decode_long_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_scalar_decode_long>>(
          'decaf_255_scalar_decode_long');
  late final _dart_decaf_255_scalar_decode_long _decaf_255_scalar_decode_long =
      _decaf_255_scalar_decode_long_ptr
          .asFunction<_dart_decaf_255_scalar_decode_long>();

  /// @brief Serialize a scalar to wire format.
  ///
  /// @param [out] ser Serialized form of a scalar.
  /// @param [in] s Deserialized scalar.
  void decaf_255_scalar_encode(
    ffi.Pointer<ffi.Uint8> ser,
    ffi.Pointer<decaf_255_scalar_t> s,
  ) {
    return _decaf_255_scalar_encode(
      ser,
      s,
    );
  }

  late final _decaf_255_scalar_encode_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_scalar_encode>>(
          'decaf_255_scalar_encode');
  late final _dart_decaf_255_scalar_encode _decaf_255_scalar_encode =
      _decaf_255_scalar_encode_ptr.asFunction<_dart_decaf_255_scalar_encode>();

  /// @brief Add two scalars.  The scalars may use the same memory.
  /// @param [in] a One scalar.
  /// @param [in] b Another scalar.
  /// @param [out] out a+b.
  void decaf_255_scalar_add(
    ffi.Pointer<decaf_255_scalar_t> out,
    ffi.Pointer<decaf_255_scalar_t> a,
    ffi.Pointer<decaf_255_scalar_t> b,
  ) {
    return _decaf_255_scalar_add(
      out,
      a,
      b,
    );
  }

  late final _decaf_255_scalar_add_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_scalar_add>>(
          'decaf_255_scalar_add');
  late final _dart_decaf_255_scalar_add _decaf_255_scalar_add =
      _decaf_255_scalar_add_ptr.asFunction<_dart_decaf_255_scalar_add>();

  /// @brief Compare two scalars.
  /// @param [in] a One scalar.
  /// @param [in] b Another scalar.
  /// @retval DECAF_TRUE The scalars are equal.
  /// @retval DECAF_FALSE The scalars are not equal.
  int decaf_255_scalar_eq(
    ffi.Pointer<decaf_255_scalar_t> a,
    ffi.Pointer<decaf_255_scalar_t> b,
  ) {
    return _decaf_255_scalar_eq(
      a,
      b,
    );
  }

  late final _decaf_255_scalar_eq_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_scalar_eq>>(
          'decaf_255_scalar_eq');
  late final _dart_decaf_255_scalar_eq _decaf_255_scalar_eq =
      _decaf_255_scalar_eq_ptr.asFunction<_dart_decaf_255_scalar_eq>();

  /// @brief Subtract two scalars.  The scalars may use the same memory.
  /// @param [in] a One scalar.
  /// @param [in] b Another scalar.
  /// @param [out] out a-b.
  void decaf_255_scalar_sub(
    ffi.Pointer<decaf_255_scalar_t> out,
    ffi.Pointer<decaf_255_scalar_t> a,
    ffi.Pointer<decaf_255_scalar_t> b,
  ) {
    return _decaf_255_scalar_sub(
      out,
      a,
      b,
    );
  }

  late final _decaf_255_scalar_sub_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_scalar_sub>>(
          'decaf_255_scalar_sub');
  late final _dart_decaf_255_scalar_sub _decaf_255_scalar_sub =
      _decaf_255_scalar_sub_ptr.asFunction<_dart_decaf_255_scalar_sub>();

  /// @brief Multiply two scalars.  The scalars may use the same memory.
  /// @param [in] a One scalar.
  /// @param [in] b Another scalar.
  /// @param [out] out a*b.
  void decaf_255_scalar_mul(
    ffi.Pointer<decaf_255_scalar_t> out,
    ffi.Pointer<decaf_255_scalar_t> a,
    ffi.Pointer<decaf_255_scalar_t> b,
  ) {
    return _decaf_255_scalar_mul(
      out,
      a,
      b,
    );
  }

  late final _decaf_255_scalar_mul_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_scalar_mul>>(
          'decaf_255_scalar_mul');
  late final _dart_decaf_255_scalar_mul _decaf_255_scalar_mul =
      _decaf_255_scalar_mul_ptr.asFunction<_dart_decaf_255_scalar_mul>();

  /// @brief Halve a scalar.  The scalars may use the same memory.
  /// @param [in] a A scalar.
  /// @param [out] out a/2.
  void decaf_255_scalar_halve(
    ffi.Pointer<decaf_255_scalar_t> out,
    ffi.Pointer<decaf_255_scalar_t> a,
  ) {
    return _decaf_255_scalar_halve(
      out,
      a,
    );
  }

  late final _decaf_255_scalar_halve_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_scalar_halve>>(
          'decaf_255_scalar_halve');
  late final _dart_decaf_255_scalar_halve _decaf_255_scalar_halve =
      _decaf_255_scalar_halve_ptr.asFunction<_dart_decaf_255_scalar_halve>();

  /// @brief Invert a scalar.  When passed zero, return 0.  The input and output may alias.
  /// @param [in] a A scalar.
  /// @param [out] out 1/a.
  /// @return DECAF_SUCCESS The input is nonzero.
  int decaf_255_scalar_invert(
    ffi.Pointer<decaf_255_scalar_t> out,
    ffi.Pointer<decaf_255_scalar_t> a,
  ) {
    return _decaf_255_scalar_invert(
      out,
      a,
    );
  }

  late final _decaf_255_scalar_invert_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_scalar_invert>>(
          'decaf_255_scalar_invert');
  late final _dart_decaf_255_scalar_invert _decaf_255_scalar_invert =
      _decaf_255_scalar_invert_ptr.asFunction<_dart_decaf_255_scalar_invert>();

  /// @brief Set a scalar to an unsigned 64-bit integer.
  /// @param [in] a An integer.
  /// @param [out] out Will become equal to a.
  void decaf_255_scalar_set_unsigned(
    ffi.Pointer<decaf_255_scalar_t> out,
    int a,
  ) {
    return _decaf_255_scalar_set_unsigned(
      out,
      a,
    );
  }

  late final _decaf_255_scalar_set_unsigned_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_scalar_set_unsigned>>(
          'decaf_255_scalar_set_unsigned');
  late final _dart_decaf_255_scalar_set_unsigned
      _decaf_255_scalar_set_unsigned = _decaf_255_scalar_set_unsigned_ptr
          .asFunction<_dart_decaf_255_scalar_set_unsigned>();

  /// @brief Encode a point as a sequence of bytes.
  ///
  /// @param [out] ser The byte representation of the point.
  /// @param [in] pt The point to encode.
  void decaf_255_point_encode(
    ffi.Pointer<ffi.Uint8> ser,
    ffi.Pointer<decaf_255_point_t> pt,
  ) {
    return _decaf_255_point_encode(
      ser,
      pt,
    );
  }

  late final _decaf_255_point_encode_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_point_encode>>(
          'decaf_255_point_encode');
  late final _dart_decaf_255_point_encode _decaf_255_point_encode =
      _decaf_255_point_encode_ptr.asFunction<_dart_decaf_255_point_encode>();

  /// @brief Decode a point from a sequence of bytes.
  ///
  /// Every point has a unique encoding, so not every
  /// sequence of bytes is a valid encoding.  If an invalid
  /// encoding is given, the output is undefined.
  ///
  /// @param [out] pt The decoded point.
  /// @param [in] ser The serialized version of the point.
  /// @param [in] allow_identity DECAF_TRUE if the identity is a legal input.
  /// @retval DECAF_SUCCESS The decoding succeeded.
  /// @retval DECAF_FAILURE The decoding didn't succeed, because
  /// ser does not represent a point.
  int decaf_255_point_decode(
    ffi.Pointer<decaf_255_point_t> pt,
    ffi.Pointer<ffi.Uint8> ser,
    int allow_identity,
  ) {
    return _decaf_255_point_decode(
      pt,
      ser,
      allow_identity,
    );
  }

  late final _decaf_255_point_decode_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_point_decode>>(
          'decaf_255_point_decode');
  late final _dart_decaf_255_point_decode _decaf_255_point_decode =
      _decaf_255_point_decode_ptr.asFunction<_dart_decaf_255_point_decode>();

  /// @brief Test whether two points are equal.  If yes, return
  /// DECAF_TRUE, else return DECAF_FALSE.
  ///
  /// @param [in] a A point.
  /// @param [in] b Another point.
  /// @retval DECAF_TRUE The points are equal.
  /// @retval DECAF_FALSE The points are not equal.
  int decaf_255_point_eq(
    ffi.Pointer<decaf_255_point_t> a,
    ffi.Pointer<decaf_255_point_t> b,
  ) {
    return _decaf_255_point_eq(
      a,
      b,
    );
  }

  late final _decaf_255_point_eq_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_point_eq>>('decaf_255_point_eq');
  late final _dart_decaf_255_point_eq _decaf_255_point_eq =
      _decaf_255_point_eq_ptr.asFunction<_dart_decaf_255_point_eq>();

  /// @brief Add two points to produce a third point.  The
  /// input points and output point can be pointers to the same
  /// memory.
  ///
  /// @param [out] sum The sum a+b.
  /// @param [in] a An addend.
  /// @param [in] b An addend.
  void decaf_255_point_add(
    ffi.Pointer<decaf_255_point_t> sum,
    ffi.Pointer<decaf_255_point_t> a,
    ffi.Pointer<decaf_255_point_t> b,
  ) {
    return _decaf_255_point_add(
      sum,
      a,
      b,
    );
  }

  late final _decaf_255_point_add_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_point_add>>(
          'decaf_255_point_add');
  late final _dart_decaf_255_point_add _decaf_255_point_add =
      _decaf_255_point_add_ptr.asFunction<_dart_decaf_255_point_add>();

  /// @brief Double a point.  Equivalent to
  /// decaf_255_point_add(two_a,a,a), but potentially faster.
  ///
  /// @param [out] two_a The sum a+a.
  /// @param [in] a A point.
  void decaf_255_point_double(
    ffi.Pointer<decaf_255_point_t> two_a,
    ffi.Pointer<decaf_255_point_t> a,
  ) {
    return _decaf_255_point_double(
      two_a,
      a,
    );
  }

  late final _decaf_255_point_double_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_point_double>>(
          'decaf_255_point_double');
  late final _dart_decaf_255_point_double _decaf_255_point_double =
      _decaf_255_point_double_ptr.asFunction<_dart_decaf_255_point_double>();

  /// @brief Subtract two points to produce a third point.  The
  /// input points and output point can be pointers to the same
  /// memory.
  ///
  /// @param [out] diff The difference a-b.
  /// @param [in] a The minuend.
  /// @param [in] b The subtrahend.
  void decaf_255_point_sub(
    ffi.Pointer<decaf_255_point_t> diff,
    ffi.Pointer<decaf_255_point_t> a,
    ffi.Pointer<decaf_255_point_t> b,
  ) {
    return _decaf_255_point_sub(
      diff,
      a,
      b,
    );
  }

  late final _decaf_255_point_sub_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_point_sub>>(
          'decaf_255_point_sub');
  late final _dart_decaf_255_point_sub _decaf_255_point_sub =
      _decaf_255_point_sub_ptr.asFunction<_dart_decaf_255_point_sub>();

  /// @brief Negate a point to produce another point.  The input
  /// and output points can use the same memory.
  ///
  /// @param [out] nega The negated input point
  /// @param [in] a The input point.
  void decaf_255_point_negate(
    ffi.Pointer<decaf_255_point_t> nega,
    ffi.Pointer<decaf_255_point_t> a,
  ) {
    return _decaf_255_point_negate(
      nega,
      a,
    );
  }

  late final _decaf_255_point_negate_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_point_negate>>(
          'decaf_255_point_negate');
  late final _dart_decaf_255_point_negate _decaf_255_point_negate =
      _decaf_255_point_negate_ptr.asFunction<_dart_decaf_255_point_negate>();

  /// @brief Multiply a base point by a scalar: scaled = scalar*base.
  ///
  /// @param [out] scaled The scaled point base*scalar
  /// @param [in] base The point to be scaled.
  /// @param [in] scalar The scalar to multiply by.
  void decaf_255_point_scalarmul(
    ffi.Pointer<decaf_255_point_t> scaled,
    ffi.Pointer<decaf_255_point_t> base,
    ffi.Pointer<decaf_255_scalar_t> scalar,
  ) {
    return _decaf_255_point_scalarmul(
      scaled,
      base,
      scalar,
    );
  }

  late final _decaf_255_point_scalarmul_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_point_scalarmul>>(
          'decaf_255_point_scalarmul');
  late final _dart_decaf_255_point_scalarmul _decaf_255_point_scalarmul =
      _decaf_255_point_scalarmul_ptr
          .asFunction<_dart_decaf_255_point_scalarmul>();

  /// @brief Multiply a base point by a scalar: scaled = scalar*base.
  /// This function operates directly on serialized forms.
  ///
  /// @warning This function is experimental.  It may not be supported
  /// long-term.
  ///
  /// @param [out] scaled The scaled point base*scalar
  /// @param [in] base The point to be scaled.
  /// @param [in] scalar The scalar to multiply by.
  /// @param [in] allow_identity Allow the input to be the identity.
  /// @param [in] short_circuit Allow a fast return if the input is illegal.
  ///
  /// @retval DECAF_SUCCESS The scalarmul succeeded.
  /// @retval DECAF_FAILURE The scalarmul didn't succeed, because
  /// base does not represent a point.
  int decaf_255_direct_scalarmul(
    ffi.Pointer<ffi.Uint8> scaled,
    ffi.Pointer<ffi.Uint8> base,
    ffi.Pointer<decaf_255_scalar_t> scalar,
    int allow_identity,
    int short_circuit,
  ) {
    return _decaf_255_direct_scalarmul(
      scaled,
      base,
      scalar,
      allow_identity,
      short_circuit,
    );
  }

  late final _decaf_255_direct_scalarmul_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_direct_scalarmul>>(
          'decaf_255_direct_scalarmul');
  late final _dart_decaf_255_direct_scalarmul _decaf_255_direct_scalarmul =
      _decaf_255_direct_scalarmul_ptr
          .asFunction<_dart_decaf_255_direct_scalarmul>();

  /// @brief RFC 7748 Diffie-Hellman scalarmul, used to compute shared secrets.
  /// This function uses a different (non-Decaf) encoding.
  ///
  /// @param [out] shared The shared secret base*scalar
  /// @param [in] base The other party's public key, used as the base of the scalarmul.
  /// @param [in] scalar The private scalar to multiply by.
  ///
  /// @retval DECAF_SUCCESS The scalarmul succeeded.
  /// @retval DECAF_FAILURE The scalarmul didn't succeed, because the base
  /// point is in a small subgroup.
  int decaf_x25519(
    ffi.Pointer<ffi.Uint8> shared,
    ffi.Pointer<ffi.Uint8> base,
    ffi.Pointer<ffi.Uint8> scalar,
  ) {
    return _decaf_x25519(
      shared,
      base,
      scalar,
    );
  }

  late final _decaf_x25519_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_x25519>>('decaf_x25519');
  late final _dart_decaf_x25519 _decaf_x25519 =
      _decaf_x25519_ptr.asFunction<_dart_decaf_x25519>();

  /// @brief Multiply a point by DECAF_X25519_ENCODE_RATIO,
  /// then encode it like RFC 7748.
  ///
  /// This function is mainly used internally, but is exported in case
  /// it will be useful.
  ///
  /// The ratio is necessary because the internal representation doesn't
  /// track the cofactor information, so on output we must clear the cofactor.
  /// This would multiply by the cofactor, but in fact internally libdecaf's
  /// points are always even, so it multiplies by half the cofactor instead.
  ///
  /// As it happens, this aligns with the base point definitions; that is,
  /// if you pass the Decaf/Ristretto base point to this function, the result
  /// will be DECAF_X25519_ENCODE_RATIO times the X25519
  /// base point.
  ///
  /// @param [out] out The scaled and encoded point.
  /// @param [in] p The point to be scaled and encoded.
  void decaf_255_point_mul_by_ratio_and_encode_like_x25519(
    ffi.Pointer<ffi.Uint8> out,
    ffi.Pointer<decaf_255_point_t> p,
  ) {
    return _decaf_255_point_mul_by_ratio_and_encode_like_x25519(
      out,
      p,
    );
  }

  late final _decaf_255_point_mul_by_ratio_and_encode_like_x25519_ptr = _lookup<
          ffi.NativeFunction<
              _c_decaf_255_point_mul_by_ratio_and_encode_like_x25519>>(
      'decaf_255_point_mul_by_ratio_and_encode_like_x25519');
  late final _dart_decaf_255_point_mul_by_ratio_and_encode_like_x25519
      _decaf_255_point_mul_by_ratio_and_encode_like_x25519 =
      _decaf_255_point_mul_by_ratio_and_encode_like_x25519_ptr.asFunction<
          _dart_decaf_255_point_mul_by_ratio_and_encode_like_x25519>();

  late final ffi.Pointer<ffi.Pointer<ffi.Uint8>> _decaf_x25519_base_point =
      _lookup<ffi.Pointer<ffi.Uint8>>('decaf_x25519_base_point');

  ffi.Pointer<ffi.Uint8> get decaf_x25519_base_point =>
      _decaf_x25519_base_point.value;

  set decaf_x25519_base_point(ffi.Pointer<ffi.Uint8> value) =>
      _decaf_x25519_base_point.value = value;

  /// @brief RFC 7748 Diffie-Hellman base point scalarmul.  This function uses
  /// a different (non-Decaf) encoding.
  ///
  /// @deprecated Renamed to decaf_x25519_derive_public_key.
  /// I have no particular timeline for removing this name.
  ///
  /// @param [out] out The public key base*scalar.
  /// @param [in] scalar The private scalar.
  void decaf_x25519_generate_key(
    ffi.Pointer<ffi.Uint8> out,
    ffi.Pointer<ffi.Uint8> scalar,
  ) {
    return _decaf_x25519_generate_key(
      out,
      scalar,
    );
  }

  late final _decaf_x25519_generate_key_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_x25519_generate_key>>(
          'decaf_x25519_generate_key');
  late final _dart_decaf_x25519_generate_key _decaf_x25519_generate_key =
      _decaf_x25519_generate_key_ptr
          .asFunction<_dart_decaf_x25519_generate_key>();

  /// @brief RFC 7748 Diffie-Hellman base point scalarmul.  This function uses
  /// a different (non-Decaf) encoding.
  ///
  /// Does exactly the same thing as decaf_x25519_generate_key,
  /// but has a better name.
  ///
  /// @param [out] out The public key base*scalar
  /// @param [in] scalar The private scalar.
  void decaf_x25519_derive_public_key(
    ffi.Pointer<ffi.Uint8> out,
    ffi.Pointer<ffi.Uint8> scalar,
  ) {
    return _decaf_x25519_derive_public_key(
      out,
      scalar,
    );
  }

  late final _decaf_x25519_derive_public_key_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_x25519_derive_public_key>>(
          'decaf_x25519_derive_public_key');
  late final _dart_decaf_x25519_derive_public_key
      _decaf_x25519_derive_public_key = _decaf_x25519_derive_public_key_ptr
          .asFunction<_dart_decaf_x25519_derive_public_key>();

  /// @brief Precompute a table for fast scalar multiplication.
  /// Some implementations do not include precomputed points; for
  /// those implementations, this implementation simply copies the
  /// point.
  ///
  /// @param [out] a A precomputed table of multiples of the point.
  /// @param [in] b Any point.
  void decaf_255_precompute(
    ffi.Pointer<decaf_255_precomputed_s> a,
    ffi.Pointer<decaf_255_point_t> b,
  ) {
    return _decaf_255_precompute(
      a,
      b,
    );
  }

  late final _decaf_255_precompute_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_precompute>>(
          'decaf_255_precompute');
  late final _dart_decaf_255_precompute _decaf_255_precompute =
      _decaf_255_precompute_ptr.asFunction<_dart_decaf_255_precompute>();

  /// @brief Multiply a precomputed base point by a scalar:
  /// scaled = scalar*base.
  /// Some implementations do not include precomputed points; for
  /// those implementations, this function is the same as
  /// decaf_255_point_scalarmul
  ///
  /// @param [out] scaled The scaled point base*scalar
  /// @param [in] base The point to be scaled.
  /// @param [in] scalar The scalar to multiply by.
  void decaf_255_precomputed_scalarmul(
    ffi.Pointer<decaf_255_point_t> scaled,
    ffi.Pointer<decaf_255_precomputed_s> base,
    ffi.Pointer<decaf_255_scalar_t> scalar,
  ) {
    return _decaf_255_precomputed_scalarmul(
      scaled,
      base,
      scalar,
    );
  }

  late final _decaf_255_precomputed_scalarmul_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_precomputed_scalarmul>>(
          'decaf_255_precomputed_scalarmul');
  late final _dart_decaf_255_precomputed_scalarmul
      _decaf_255_precomputed_scalarmul = _decaf_255_precomputed_scalarmul_ptr
          .asFunction<_dart_decaf_255_precomputed_scalarmul>();

  /// @brief Multiply two base points by two scalars:
  /// scaled = scalar1*base1 + scalar2*base2.
  ///
  /// Equivalent to two calls to decaf_255_point_scalarmul, but may be
  /// faster.
  ///
  /// @param [out] combo The linear combination scalar1*base1 + scalar2*base2.
  /// @param [in] base1 A first point to be scaled.
  /// @param [in] scalar1 A first scalar to multiply by.
  /// @param [in] base2 A second point to be scaled.
  /// @param [in] scalar2 A second scalar to multiply by.
  void decaf_255_point_double_scalarmul(
    ffi.Pointer<decaf_255_point_t> combo,
    ffi.Pointer<decaf_255_point_t> base1,
    ffi.Pointer<decaf_255_scalar_t> scalar1,
    ffi.Pointer<decaf_255_point_t> base2,
    ffi.Pointer<decaf_255_scalar_t> scalar2,
  ) {
    return _decaf_255_point_double_scalarmul(
      combo,
      base1,
      scalar1,
      base2,
      scalar2,
    );
  }

  late final _decaf_255_point_double_scalarmul_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_point_double_scalarmul>>(
          'decaf_255_point_double_scalarmul');
  late final _dart_decaf_255_point_double_scalarmul
      _decaf_255_point_double_scalarmul = _decaf_255_point_double_scalarmul_ptr
          .asFunction<_dart_decaf_255_point_double_scalarmul>();

  /// Multiply one base point by two scalars:
  ///
  /// a1 = scalar1 * base
  /// a2 = scalar2 * base
  ///
  /// Equivalent to two calls to decaf_255_point_scalarmul, but may be
  /// faster.
  ///
  /// @param [out] a1 The first multiple.  It may be the same as the input point.
  /// @param [out] a2 The second multiple.  It may be the same as the input point.
  /// @param [in] base1 A point to be scaled.
  /// @param [in] scalar1 A first scalar to multiply by.
  /// @param [in] scalar2 A second scalar to multiply by.
  void decaf_255_point_dual_scalarmul(
    ffi.Pointer<decaf_255_point_t> a1,
    ffi.Pointer<decaf_255_point_t> a2,
    ffi.Pointer<decaf_255_point_t> base1,
    ffi.Pointer<decaf_255_scalar_t> scalar1,
    ffi.Pointer<decaf_255_scalar_t> scalar2,
  ) {
    return _decaf_255_point_dual_scalarmul(
      a1,
      a2,
      base1,
      scalar1,
      scalar2,
    );
  }

  late final _decaf_255_point_dual_scalarmul_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_point_dual_scalarmul>>(
          'decaf_255_point_dual_scalarmul');
  late final _dart_decaf_255_point_dual_scalarmul
      _decaf_255_point_dual_scalarmul = _decaf_255_point_dual_scalarmul_ptr
          .asFunction<_dart_decaf_255_point_dual_scalarmul>();

  /// @brief Multiply two base points by two scalars:
  /// scaled = scalar1*decaf_255_point_base + scalar2*base2.
  ///
  /// Otherwise equivalent to decaf_255_point_double_scalarmul, but may be
  /// faster at the expense of being variable time.
  ///
  /// @param [out] combo The linear combination scalar1*base + scalar2*base2.
  /// @param [in] scalar1 A first scalar to multiply by.
  /// @param [in] base2 A second point to be scaled.
  /// @param [in] scalar2 A second scalar to multiply by.
  ///
  /// @warning: This function takes variable time, and may leak the scalars
  /// used.  It is designed for signature verification.
  void decaf_255_base_double_scalarmul_non_secret(
    ffi.Pointer<decaf_255_point_t> combo,
    ffi.Pointer<decaf_255_scalar_t> scalar1,
    ffi.Pointer<decaf_255_point_t> base2,
    ffi.Pointer<decaf_255_scalar_t> scalar2,
  ) {
    return _decaf_255_base_double_scalarmul_non_secret(
      combo,
      scalar1,
      base2,
      scalar2,
    );
  }

  late final _decaf_255_base_double_scalarmul_non_secret_ptr = _lookup<
          ffi.NativeFunction<_c_decaf_255_base_double_scalarmul_non_secret>>(
      'decaf_255_base_double_scalarmul_non_secret');
  late final _dart_decaf_255_base_double_scalarmul_non_secret
      _decaf_255_base_double_scalarmul_non_secret =
      _decaf_255_base_double_scalarmul_non_secret_ptr
          .asFunction<_dart_decaf_255_base_double_scalarmul_non_secret>();

  /// @brief Constant-time decision between two points.  If pick_b
  /// is zero, out = a; else out = b.
  ///
  /// @param [out] out The output.  It may be the same as either input.
  /// @param [in] a Any point.
  /// @param [in] b Any point.
  /// @param [in] pick_b If nonzero, choose point b.
  void decaf_255_point_cond_sel(
    ffi.Pointer<decaf_255_point_t> out,
    ffi.Pointer<decaf_255_point_t> a,
    ffi.Pointer<decaf_255_point_t> b,
    int pick_b,
  ) {
    return _decaf_255_point_cond_sel(
      out,
      a,
      b,
      pick_b,
    );
  }

  late final _decaf_255_point_cond_sel_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_point_cond_sel>>(
          'decaf_255_point_cond_sel');
  late final _dart_decaf_255_point_cond_sel _decaf_255_point_cond_sel =
      _decaf_255_point_cond_sel_ptr
          .asFunction<_dart_decaf_255_point_cond_sel>();

  /// @brief Constant-time decision between two scalars.  If pick_b
  /// is zero, out = a; else out = b.
  ///
  /// @param [out] out The output.  It may be the same as either input.
  /// @param [in] a Any scalar.
  /// @param [in] b Any scalar.
  /// @param [in] pick_b If nonzero, choose scalar b.
  void decaf_255_scalar_cond_sel(
    ffi.Pointer<decaf_255_scalar_t> out,
    ffi.Pointer<decaf_255_scalar_t> a,
    ffi.Pointer<decaf_255_scalar_t> b,
    int pick_b,
  ) {
    return _decaf_255_scalar_cond_sel(
      out,
      a,
      b,
      pick_b,
    );
  }

  late final _decaf_255_scalar_cond_sel_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_scalar_cond_sel>>(
          'decaf_255_scalar_cond_sel');
  late final _dart_decaf_255_scalar_cond_sel _decaf_255_scalar_cond_sel =
      _decaf_255_scalar_cond_sel_ptr
          .asFunction<_dart_decaf_255_scalar_cond_sel>();

  /// @brief Test that a point is valid, for debugging purposes.
  ///
  /// @param [in] to_test The point to test.
  /// @retval DECAF_TRUE The point is valid.
  /// @retval DECAF_FALSE The point is invalid.
  int decaf_255_point_valid(
    ffi.Pointer<decaf_255_point_t> to_test,
  ) {
    return _decaf_255_point_valid(
      to_test,
    );
  }

  late final _decaf_255_point_valid_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_point_valid>>(
          'decaf_255_point_valid');
  late final _dart_decaf_255_point_valid _decaf_255_point_valid =
      _decaf_255_point_valid_ptr.asFunction<_dart_decaf_255_point_valid>();

  /// @brief Torque a point, for debugging purposes.  The output
  /// will be equal to the input.
  ///
  /// @param [out] q The point to torque.
  /// @param [in] p The point to torque.
  void decaf_255_point_debugging_torque(
    ffi.Pointer<decaf_255_point_t> q,
    ffi.Pointer<decaf_255_point_t> p,
  ) {
    return _decaf_255_point_debugging_torque(
      q,
      p,
    );
  }

  late final _decaf_255_point_debugging_torque_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_point_debugging_torque>>(
          'decaf_255_point_debugging_torque');
  late final _dart_decaf_255_point_debugging_torque
      _decaf_255_point_debugging_torque = _decaf_255_point_debugging_torque_ptr
          .asFunction<_dart_decaf_255_point_debugging_torque>();

  /// @brief Projectively scale a point, for debugging purposes.
  /// The output will be equal to the input, and will be valid
  /// even if the factor is zero.
  ///
  /// @param [out] q The point to scale.
  /// @param [in] p The point to scale.
  /// @param [in] factor Serialized GF factor to scale.
  void decaf_255_point_debugging_pscale(
    ffi.Pointer<decaf_255_point_t> q,
    ffi.Pointer<decaf_255_point_t> p,
    ffi.Pointer<ffi.Uint8> factor,
  ) {
    return _decaf_255_point_debugging_pscale(
      q,
      p,
      factor,
    );
  }

  late final _decaf_255_point_debugging_pscale_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_point_debugging_pscale>>(
          'decaf_255_point_debugging_pscale');
  late final _dart_decaf_255_point_debugging_pscale
      _decaf_255_point_debugging_pscale = _decaf_255_point_debugging_pscale_ptr
          .asFunction<_dart_decaf_255_point_debugging_pscale>();

  /// @brief Almost-Elligator-like hash to curve.
  ///
  /// Call this function with the output of a hash to make a hash to the curve.
  ///
  /// This function runs Elligator2 on the decaf_255 Jacobi quartic model.  It then
  /// uses the isogeny to put the result in twisted Edwards form.  As a result,
  /// it is safe (cannot produce points of order 4), and would be compatible with
  /// hypothetical other implementations of Decaf using a Montgomery or untwisted
  /// Edwards model.
  ///
  /// Unlike Elligator, this function may be up to 4:1 on [0,(p-1)/2]:
  /// A factor of 2 due to the isogeny.
  /// A factor of 2 because we quotient out the 2-torsion.
  ///
  /// This makes it about 8:1 overall, or 16:1 overall on curves with cofactor 8.
  ///
  /// Negating the input (mod q) results in the same point.  Inverting the input
  /// (mod q) results in the negative point.  This is the same as Elligator.
  ///
  /// This function isn't quite indifferentiable from a random oracle.
  /// However, it is suitable for many protocols, including SPEKE and SPAKE2 EE.
  /// Furthermore, calling it twice with independent seeds and adding the results
  /// is indifferentiable from a random oracle.
  ///
  /// @param [in] hashed_data Output of some hash function.
  /// @param [out] pt The data hashed to the curve.
  void decaf_255_point_from_hash_nonuniform(
    ffi.Pointer<decaf_255_point_t> pt,
    ffi.Pointer<ffi.Uint8> hashed_data,
  ) {
    return _decaf_255_point_from_hash_nonuniform(
      pt,
      hashed_data,
    );
  }

  late final _decaf_255_point_from_hash_nonuniform_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_point_from_hash_nonuniform>>(
          'decaf_255_point_from_hash_nonuniform');
  late final _dart_decaf_255_point_from_hash_nonuniform
      _decaf_255_point_from_hash_nonuniform =
      _decaf_255_point_from_hash_nonuniform_ptr
          .asFunction<_dart_decaf_255_point_from_hash_nonuniform>();

  /// @brief Indifferentiable hash function encoding to curve.
  ///
  /// Equivalent to calling decaf_255_point_from_hash_nonuniform twice and adding.
  ///
  /// @param [in] hashed_data Output of some hash function.
  /// @param [out] pt The data hashed to the curve.
  void decaf_255_point_from_hash_uniform(
    ffi.Pointer<decaf_255_point_t> pt,
    ffi.Pointer<ffi.Uint8> hashed_data,
  ) {
    return _decaf_255_point_from_hash_uniform(
      pt,
      hashed_data,
    );
  }

  late final _decaf_255_point_from_hash_uniform_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_point_from_hash_uniform>>(
          'decaf_255_point_from_hash_uniform');
  late final _dart_decaf_255_point_from_hash_uniform
      _decaf_255_point_from_hash_uniform =
      _decaf_255_point_from_hash_uniform_ptr
          .asFunction<_dart_decaf_255_point_from_hash_uniform>();

  /// @brief Inverse of elligator-like hash to curve.
  ///
  /// This function writes to the buffer, to make it so that
  /// decaf_255_point_from_hash_nonuniform(buffer) = pt if
  /// possible.  Since there may be multiple preimages, the
  /// "which" parameter chooses between them.  To ensure uniform
  /// inverse sampling, this function succeeds or fails
  /// independently for different "which" values.
  ///
  /// This function isn't guaranteed to find every possible
  /// preimage, but it finds all except a small finite number.
  /// In particular, when the number of bits in the modulus isn't
  /// a multiple of 8 (i.e. for curve25519), it sets the high bits
  /// independently, which enables the generated data to be uniform.
  /// But it doesn't add p, so you'll never get exactly p from this
  /// function.  This might change in the future, especially if
  /// we ever support eg Brainpool curves, where this could cause
  /// real nonuniformity.
  ///
  /// @param [out] recovered_hash Encoded data.
  /// @param [in] pt The point to encode.
  /// @param [in] which A value determining which inverse point
  /// to return.
  ///
  /// @retval DECAF_SUCCESS The inverse succeeded.
  /// @retval DECAF_FAILURE The inverse failed.
  int decaf_255_invert_elligator_nonuniform(
    ffi.Pointer<ffi.Uint8> recovered_hash,
    ffi.Pointer<decaf_255_point_t> pt,
    int which,
  ) {
    return _decaf_255_invert_elligator_nonuniform(
      recovered_hash,
      pt,
      which,
    );
  }

  late final _decaf_255_invert_elligator_nonuniform_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_invert_elligator_nonuniform>>(
          'decaf_255_invert_elligator_nonuniform');
  late final _dart_decaf_255_invert_elligator_nonuniform
      _decaf_255_invert_elligator_nonuniform =
      _decaf_255_invert_elligator_nonuniform_ptr
          .asFunction<_dart_decaf_255_invert_elligator_nonuniform>();

  /// @brief Inverse of elligator-like hash to curve.
  ///
  /// This function writes to the buffer, to make it so that
  /// decaf_255_point_from_hash_uniform(buffer) = pt if
  /// possible.  Since there may be multiple preimages, the
  /// "which" parameter chooses between them.  To ensure uniform
  /// inverse sampling, this function succeeds or fails
  /// independently for different "which" values.
  ///
  /// @param [out] recovered_hash Encoded data.
  /// @param [in] pt The point to encode.
  /// @param [in] which A value determining which inverse point
  /// to return.
  ///
  /// @retval DECAF_SUCCESS The inverse succeeded.
  /// @retval DECAF_FAILURE The inverse failed.
  int decaf_255_invert_elligator_uniform(
    ffi.Pointer<ffi.Uint8> recovered_hash,
    ffi.Pointer<decaf_255_point_t> pt,
    int which,
  ) {
    return _decaf_255_invert_elligator_uniform(
      recovered_hash,
      pt,
      which,
    );
  }

  late final _decaf_255_invert_elligator_uniform_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_invert_elligator_uniform>>(
          'decaf_255_invert_elligator_uniform');
  late final _dart_decaf_255_invert_elligator_uniform
      _decaf_255_invert_elligator_uniform =
      _decaf_255_invert_elligator_uniform_ptr
          .asFunction<_dart_decaf_255_invert_elligator_uniform>();

  /// Securely erase a scalar.
  void decaf_255_scalar_destroy(
    ffi.Pointer<decaf_255_scalar_t> scalar,
  ) {
    return _decaf_255_scalar_destroy(
      scalar,
    );
  }

  late final _decaf_255_scalar_destroy_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_scalar_destroy>>(
          'decaf_255_scalar_destroy');
  late final _dart_decaf_255_scalar_destroy _decaf_255_scalar_destroy =
      _decaf_255_scalar_destroy_ptr
          .asFunction<_dart_decaf_255_scalar_destroy>();

  /// Securely erase a point by overwriting it with zeros.
  /// @warning This causes the point object to become invalid.
  void decaf_255_point_destroy(
    ffi.Pointer<decaf_255_point_t> point,
  ) {
    return _decaf_255_point_destroy(
      point,
    );
  }

  late final _decaf_255_point_destroy_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_point_destroy>>(
          'decaf_255_point_destroy');
  late final _dart_decaf_255_point_destroy _decaf_255_point_destroy =
      _decaf_255_point_destroy_ptr.asFunction<_dart_decaf_255_point_destroy>();

  /// Securely erase a precomputed table by overwriting it with zeros.
  /// @warning This causes the table object to become invalid.
  void decaf_255_precomputed_destroy(
    ffi.Pointer<decaf_255_precomputed_s> pre,
  ) {
    return _decaf_255_precomputed_destroy(
      pre,
    );
  }

  late final _decaf_255_precomputed_destroy_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_255_precomputed_destroy>>(
          'decaf_255_precomputed_destroy');
  late final _dart_decaf_255_precomputed_destroy
      _decaf_255_precomputed_destroy = _decaf_255_precomputed_destroy_ptr
          .asFunction<_dart_decaf_255_precomputed_destroy>();

  /// @brief Initialize a sponge context object.
  /// @param [out] sponge The object to initialize.
  /// @param [in] params The sponge's parameter description.
  void decaf_sha3_init(
    ffi.Pointer<decaf_keccak_sponge_s> sponge,
    ffi.Pointer<decaf_kparams_s> params,
  ) {
    return _decaf_sha3_init(
      sponge,
      params,
    );
  }

  late final _decaf_sha3_init_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_sha3_init>>('decaf_sha3_init');
  late final _dart_decaf_sha3_init _decaf_sha3_init =
      _decaf_sha3_init_ptr.asFunction<_dart_decaf_sha3_init>();

  /// @brief Absorb data into a DECAF_SHA3 or DECAF_SHAKE hash context.
  /// @param [inout] sponge The context.
  /// @param [in] in The input data.
  /// @param [in] len The input data's length in bytes.
  /// @return DECAF_FAILURE if the sponge has already been used for output.
  /// @return DECAF_SUCCESS otherwise.
  int decaf_sha3_update(
    ffi.Pointer<decaf_keccak_sponge_s> sponge,
    ffi.Pointer<ffi.Uint8> in_1,
    int len,
  ) {
    return _decaf_sha3_update(
      sponge,
      in_1,
      len,
    );
  }

  late final _decaf_sha3_update_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_sha3_update>>('decaf_sha3_update');
  late final _dart_decaf_sha3_update _decaf_sha3_update =
      _decaf_sha3_update_ptr.asFunction<_dart_decaf_sha3_update>();

  /// @brief Squeeze output data from a DECAF_SHA3 or DECAF_SHAKE hash context.
  /// This does not destroy or re-initialize the hash context, and
  /// decaf_sha3 output can be called more times.
  ///
  /// @param [inout] sponge The context.
  /// @param [out] out The output data.
  /// @param [in] len The requested output data length in bytes.
  /// @return DECAF_FAILURE if the sponge has exhausted its output capacity.
  /// @return DECAF_SUCCESS otherwise.
  int decaf_sha3_output(
    ffi.Pointer<decaf_keccak_sponge_s> sponge,
    ffi.Pointer<ffi.Uint8> out,
    int len,
  ) {
    return _decaf_sha3_output(
      sponge,
      out,
      len,
    );
  }

  late final _decaf_sha3_output_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_sha3_output>>('decaf_sha3_output');
  late final _dart_decaf_sha3_output _decaf_sha3_output =
      _decaf_sha3_output_ptr.asFunction<_dart_decaf_sha3_output>();

  /// @brief Squeeze output data from a DECAF_SHA3 or DECAF_SHAKE hash context.
  /// This re-initializes the context to its starting parameters.
  ///
  /// @param [inout] sponge The context.
  /// @param [out] out The output data.
  /// @param [in] len The requested output data length in bytes.
  int decaf_sha3_final(
    ffi.Pointer<decaf_keccak_sponge_s> sponge,
    ffi.Pointer<ffi.Uint8> out,
    int len,
  ) {
    return _decaf_sha3_final(
      sponge,
      out,
      len,
    );
  }

  late final _decaf_sha3_final_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_sha3_final>>('decaf_sha3_final');
  late final _dart_decaf_sha3_final _decaf_sha3_final =
      _decaf_sha3_final_ptr.asFunction<_dart_decaf_sha3_final>();

  /// @brief Reset the sponge to the empty string.
  ///
  /// @param [inout] sponge The context.
  void decaf_sha3_reset(
    ffi.Pointer<decaf_keccak_sponge_s> sponge,
  ) {
    return _decaf_sha3_reset(
      sponge,
    );
  }

  late final _decaf_sha3_reset_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_sha3_reset>>('decaf_sha3_reset');
  late final _dart_decaf_sha3_reset _decaf_sha3_reset =
      _decaf_sha3_reset_ptr.asFunction<_dart_decaf_sha3_reset>();

  /// @brief Return the default output length of the sponge construction,
  /// for the purpose of C++ default operators.
  ///
  /// Returns n/8 for DECAF_SHA3-n and 2n/8 for DECAF_SHAKE-n.
  int decaf_sha3_default_output_bytes(
    ffi.Pointer<decaf_keccak_sponge_s> sponge,
  ) {
    return _decaf_sha3_default_output_bytes(
      sponge,
    );
  }

  late final _decaf_sha3_default_output_bytes_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_sha3_default_output_bytes>>(
          'decaf_sha3_default_output_bytes');
  late final _dart_decaf_sha3_default_output_bytes
      _decaf_sha3_default_output_bytes = _decaf_sha3_default_output_bytes_ptr
          .asFunction<_dart_decaf_sha3_default_output_bytes>();

  /// @brief Return the default output length of the sponge construction,
  /// for the purpose of C++ default operators.
  ///
  /// Returns n/8 for DECAF_SHA3-n and SIZE_MAX for DECAF_SHAKE-n.
  int decaf_sha3_max_output_bytes(
    ffi.Pointer<decaf_keccak_sponge_s> sponge,
  ) {
    return _decaf_sha3_max_output_bytes(
      sponge,
    );
  }

  late final _decaf_sha3_max_output_bytes_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_sha3_max_output_bytes>>(
          'decaf_sha3_max_output_bytes');
  late final _dart_decaf_sha3_max_output_bytes _decaf_sha3_max_output_bytes =
      _decaf_sha3_max_output_bytes_ptr
          .asFunction<_dart_decaf_sha3_max_output_bytes>();

  /// @brief Destroy a DECAF_SHA3 or DECAF_SHAKE sponge context by overwriting it with 0.
  /// @param [out] sponge The context.
  void decaf_sha3_destroy(
    ffi.Pointer<decaf_keccak_sponge_s> sponge,
  ) {
    return _decaf_sha3_destroy(
      sponge,
    );
  }

  late final _decaf_sha3_destroy_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_sha3_destroy>>('decaf_sha3_destroy');
  late final _dart_decaf_sha3_destroy _decaf_sha3_destroy =
      _decaf_sha3_destroy_ptr.asFunction<_dart_decaf_sha3_destroy>();

  /// @brief Hash (in) to (out)
  /// @param [in] in The input data.
  /// @param [in] inlen The length of the input data.
  /// @param [out] out A buffer for the output data.
  /// @param [in] outlen The length of the output data.
  /// @param [in] params The parameters of the sponge hash.
  int decaf_sha3_hash(
    ffi.Pointer<ffi.Uint8> out,
    int outlen,
    ffi.Pointer<ffi.Uint8> in_1,
    int inlen,
    ffi.Pointer<decaf_kparams_s> params,
  ) {
    return _decaf_sha3_hash(
      out,
      outlen,
      in_1,
      inlen,
      params,
    );
  }

  late final _decaf_sha3_hash_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_sha3_hash>>('decaf_sha3_hash');
  late final _dart_decaf_sha3_hash _decaf_sha3_hash =
      _decaf_sha3_hash_ptr.asFunction<_dart_decaf_sha3_hash>();

  late final ffi.Pointer<decaf_kparams_s> _DECAF_SHAKE128_params_s =
      _lookup<decaf_kparams_s>('DECAF_SHAKE128_params_s');

  ffi.Pointer<decaf_kparams_s> get DECAF_SHAKE128_params_s =>
      _DECAF_SHAKE128_params_s;

  late final ffi.Pointer<decaf_kparams_s> _DECAF_SHAKE256_params_s =
      _lookup<decaf_kparams_s>('DECAF_SHAKE256_params_s');

  ffi.Pointer<decaf_kparams_s> get DECAF_SHAKE256_params_s =>
      _DECAF_SHAKE256_params_s;

  late final ffi.Pointer<decaf_kparams_s> _DECAF_SHA3_224_params_s =
      _lookup<decaf_kparams_s>('DECAF_SHA3_224_params_s');

  ffi.Pointer<decaf_kparams_s> get DECAF_SHA3_224_params_s =>
      _DECAF_SHA3_224_params_s;

  late final ffi.Pointer<decaf_kparams_s> _DECAF_SHA3_256_params_s =
      _lookup<decaf_kparams_s>('DECAF_SHA3_256_params_s');

  ffi.Pointer<decaf_kparams_s> get DECAF_SHA3_256_params_s =>
      _DECAF_SHA3_256_params_s;

  late final ffi.Pointer<decaf_kparams_s> _DECAF_SHA3_384_params_s =
      _lookup<decaf_kparams_s>('DECAF_SHA3_384_params_s');

  ffi.Pointer<decaf_kparams_s> get DECAF_SHA3_384_params_s =>
      _DECAF_SHA3_384_params_s;

  late final ffi.Pointer<decaf_kparams_s> _DECAF_SHA3_512_params_s =
      _lookup<decaf_kparams_s>('DECAF_SHA3_512_params_s');

  ffi.Pointer<decaf_kparams_s> get DECAF_SHA3_512_params_s =>
      _DECAF_SHA3_512_params_s;

  /// Initialize a sponge-based CSPRNG from a buffer.
  void decaf_spongerng_init_from_buffer(
    ffi.Pointer<decaf_keccak_prng_s> prng,
    ffi.Pointer<ffi.Uint8> in_1,
    int len,
    int deterministic,
  ) {
    return _decaf_spongerng_init_from_buffer(
      prng,
      in_1,
      len,
      deterministic,
    );
  }

  late final _decaf_spongerng_init_from_buffer_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_spongerng_init_from_buffer>>(
          'decaf_spongerng_init_from_buffer');
  late final _dart_decaf_spongerng_init_from_buffer
      _decaf_spongerng_init_from_buffer = _decaf_spongerng_init_from_buffer_ptr
          .asFunction<_dart_decaf_spongerng_init_from_buffer>();

  /// @brief Initialize a sponge-based CSPRNG from a file.
  /// @retval DECAF_SUCCESS success.
  /// @retval DECAF_FAILURE failure.
  /// @note On failure, errno can be used to determine the cause.
  int decaf_spongerng_init_from_file(
    ffi.Pointer<decaf_keccak_prng_s> prng,
    ffi.Pointer<ffi.Int8> file,
    int len,
    int deterministic,
  ) {
    return _decaf_spongerng_init_from_file(
      prng,
      file,
      len,
      deterministic,
    );
  }

  late final _decaf_spongerng_init_from_file_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_spongerng_init_from_file>>(
          'decaf_spongerng_init_from_file');
  late final _dart_decaf_spongerng_init_from_file
      _decaf_spongerng_init_from_file = _decaf_spongerng_init_from_file_ptr
          .asFunction<_dart_decaf_spongerng_init_from_file>();

  /// @brief Initialize a nondeterministic sponge-based CSPRNG from /dev/urandom.
  /// @retval DECAF_SUCCESS success.
  /// @retval DECAF_FAILURE failure.
  /// @note On failure, errno can be used to determine the cause.
  int decaf_spongerng_init_from_dev_urandom(
    ffi.Pointer<decaf_keccak_prng_s> prng,
  ) {
    return _decaf_spongerng_init_from_dev_urandom(
      prng,
    );
  }

  late final _decaf_spongerng_init_from_dev_urandom_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_spongerng_init_from_dev_urandom>>(
          'decaf_spongerng_init_from_dev_urandom');
  late final _dart_decaf_spongerng_init_from_dev_urandom
      _decaf_spongerng_init_from_dev_urandom =
      _decaf_spongerng_init_from_dev_urandom_ptr
          .asFunction<_dart_decaf_spongerng_init_from_dev_urandom>();

  /// Output bytes from a sponge-based CSPRNG.
  void decaf_spongerng_next(
    ffi.Pointer<decaf_keccak_prng_s> prng,
    ffi.Pointer<ffi.Uint8> out,
    int len,
  ) {
    return _decaf_spongerng_next(
      prng,
      out,
      len,
    );
  }

  late final _decaf_spongerng_next_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_spongerng_next>>(
          'decaf_spongerng_next');
  late final _dart_decaf_spongerng_next _decaf_spongerng_next =
      _decaf_spongerng_next_ptr.asFunction<_dart_decaf_spongerng_next>();

  /// Stir entropy data into a sponge-based CSPRNG from a buffer.
  void decaf_spongerng_stir(
    ffi.Pointer<decaf_keccak_prng_s> prng,
    ffi.Pointer<ffi.Uint8> in_1,
    int len,
  ) {
    return _decaf_spongerng_stir(
      prng,
      in_1,
      len,
    );
  }

  late final _decaf_spongerng_stir_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_spongerng_stir>>(
          'decaf_spongerng_stir');
  late final _dart_decaf_spongerng_stir _decaf_spongerng_stir =
      _decaf_spongerng_stir_ptr.asFunction<_dart_decaf_spongerng_stir>();

  /// @brief EdDSA key generation.  This function uses a different (non-Decaf)
  /// encoding.
  ///
  /// @param [out] pubkey The public key.
  /// @param [in] privkey The private key.
  void decaf_ed448_derive_public_key(
    ffi.Pointer<ffi.Uint8> pubkey,
    ffi.Pointer<ffi.Uint8> privkey,
  ) {
    return _decaf_ed448_derive_public_key(
      pubkey,
      privkey,
    );
  }

  late final _decaf_ed448_derive_public_key_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_ed448_derive_public_key>>(
          'decaf_ed448_derive_public_key');
  late final _dart_decaf_ed448_derive_public_key
      _decaf_ed448_derive_public_key = _decaf_ed448_derive_public_key_ptr
          .asFunction<_dart_decaf_ed448_derive_public_key>();

  /// @brief EdDSA signing.
  ///
  /// @param [out] signature The signature.
  /// @param [in] privkey The private key.
  /// @param [in] pubkey The public key.
  /// @param [in] message The message to sign.
  /// @param [in] message_len The length of the message.
  /// @param [in] prehashed Nonzero if the message is actually the hash of something you want to sign.
  /// @param [in] context A "context" for this signature of up to 255 bytes.
  /// @param [in] context_len Length of the context.
  ///
  /// @warning For Ed25519, it is unsafe to use the same key for both prehashed and non-prehashed
  /// messages, at least without some very careful protocol-level disambiguation.  For Ed448 it is
  /// safe.  The C++ wrapper is designed to make it harder to screw this up, but this C code gives
  /// you no seat belt.
  void decaf_ed448_sign(
    ffi.Pointer<ffi.Uint8> signature,
    ffi.Pointer<ffi.Uint8> privkey,
    ffi.Pointer<ffi.Uint8> pubkey,
    ffi.Pointer<ffi.Uint8> message,
    int message_len,
    int prehashed,
    ffi.Pointer<ffi.Uint8> context,
    int context_len,
  ) {
    return _decaf_ed448_sign(
      signature,
      privkey,
      pubkey,
      message,
      message_len,
      prehashed,
      context,
      context_len,
    );
  }

  late final _decaf_ed448_sign_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_ed448_sign>>('decaf_ed448_sign');
  late final _dart_decaf_ed448_sign _decaf_ed448_sign =
      _decaf_ed448_sign_ptr.asFunction<_dart_decaf_ed448_sign>();

  /// @brief EdDSA signing with prehash.
  ///
  /// @param [out] signature The signature.
  /// @param [in] privkey The private key.
  /// @param [in] pubkey The public key.
  /// @param [in] hash The hash of the message.  This object will not be modified by the call.
  /// @param [in] context A "context" for this signature of up to 255 bytes.  Must be the same as what was used for the prehash.
  /// @param [in] context_len Length of the context.
  ///
  /// @warning For Ed25519, it is unsafe to use the same key for both prehashed and non-prehashed
  /// messages, at least without some very careful protocol-level disambiguation.  For Ed448 it is
  /// safe.  The C++ wrapper is designed to make it harder to screw this up, but this C code gives
  /// you no seat belt.
  void decaf_ed448_sign_prehash(
    ffi.Pointer<ffi.Uint8> signature,
    ffi.Pointer<ffi.Uint8> privkey,
    ffi.Pointer<ffi.Uint8> pubkey,
    ffi.Pointer<decaf_shake256_ctx_t> hash,
    ffi.Pointer<ffi.Uint8> context,
    int context_len,
  ) {
    return _decaf_ed448_sign_prehash(
      signature,
      privkey,
      pubkey,
      hash,
      context,
      context_len,
    );
  }

  late final _decaf_ed448_sign_prehash_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_ed448_sign_prehash>>(
          'decaf_ed448_sign_prehash');
  late final _dart_decaf_ed448_sign_prehash _decaf_ed448_sign_prehash =
      _decaf_ed448_sign_prehash_ptr
          .asFunction<_dart_decaf_ed448_sign_prehash>();

  /// @brief Prehash initialization, with contexts if supported.
  ///
  /// @param [out] hash The hash object to be initialized.
  void decaf_ed448_prehash_init(
    ffi.Pointer<decaf_shake256_ctx_t> hash,
  ) {
    return _decaf_ed448_prehash_init(
      hash,
    );
  }

  late final _decaf_ed448_prehash_init_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_ed448_prehash_init>>(
          'decaf_ed448_prehash_init');
  late final _dart_decaf_ed448_prehash_init _decaf_ed448_prehash_init =
      _decaf_ed448_prehash_init_ptr
          .asFunction<_dart_decaf_ed448_prehash_init>();

  /// @brief EdDSA signature verification.
  ///
  /// Uses the standard (i.e. less-strict) verification formula.
  ///
  /// @param [in] signature The signature.
  /// @param [in] pubkey The public key.
  /// @param [in] message The message to verify.
  /// @param [in] message_len The length of the message.
  /// @param [in] prehashed Nonzero if the message is actually the hash of something you want to verify.
  /// @param [in] context A "context" for this signature of up to 255 bytes.
  /// @param [in] context_len Length of the context.
  ///
  /// @warning For Ed25519, it is unsafe to use the same key for both prehashed and non-prehashed
  /// messages, at least without some very careful protocol-level disambiguation.  For Ed448 it is
  /// safe.  The C++ wrapper is designed to make it harder to screw this up, but this C code gives
  /// you no seat belt.
  int decaf_ed448_verify(
    ffi.Pointer<ffi.Uint8> signature,
    ffi.Pointer<ffi.Uint8> pubkey,
    ffi.Pointer<ffi.Uint8> message,
    int message_len,
    int prehashed,
    ffi.Pointer<ffi.Uint8> context,
    int context_len,
  ) {
    return _decaf_ed448_verify(
      signature,
      pubkey,
      message,
      message_len,
      prehashed,
      context,
      context_len,
    );
  }

  late final _decaf_ed448_verify_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_ed448_verify>>('decaf_ed448_verify');
  late final _dart_decaf_ed448_verify _decaf_ed448_verify =
      _decaf_ed448_verify_ptr.asFunction<_dart_decaf_ed448_verify>();

  /// @brief EdDSA signature verification.
  ///
  /// Uses the standard (i.e. less-strict) verification formula.
  ///
  /// @param [in] signature The signature.
  /// @param [in] pubkey The public key.
  /// @param [in] hash The hash of the message.  This object will not be modified by the call.
  /// @param [in] context A "context" for this signature of up to 255 bytes.  Must be the same as what was used for the prehash.
  /// @param [in] context_len Length of the context.
  ///
  /// @warning For Ed25519, it is unsafe to use the same key for both prehashed and non-prehashed
  /// messages, at least without some very careful protocol-level disambiguation.  For Ed448 it is
  /// safe.  The C++ wrapper is designed to make it harder to screw this up, but this C code gives
  /// you no seat belt.
  int decaf_ed448_verify_prehash(
    ffi.Pointer<ffi.Uint8> signature,
    ffi.Pointer<ffi.Uint8> pubkey,
    ffi.Pointer<decaf_shake256_ctx_t> hash,
    ffi.Pointer<ffi.Uint8> context,
    int context_len,
  ) {
    return _decaf_ed448_verify_prehash(
      signature,
      pubkey,
      hash,
      context,
      context_len,
    );
  }

  late final _decaf_ed448_verify_prehash_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_ed448_verify_prehash>>(
          'decaf_ed448_verify_prehash');
  late final _dart_decaf_ed448_verify_prehash _decaf_ed448_verify_prehash =
      _decaf_ed448_verify_prehash_ptr
          .asFunction<_dart_decaf_ed448_verify_prehash>();

  /// @brief EdDSA point encoding.  Used internally, exposed externally.
  /// Multiplies by DECAF_448_EDDSA_ENCODE_RATIO first.
  ///
  /// The multiplication is required because the EdDSA encoding represents
  /// the cofactor information, but the Decaf encoding ignores it (which
  /// is the whole point).  So if you decode from EdDSA and re-encode to
  /// EdDSA, the cofactor info must get cleared, because the intermediate
  /// representation doesn't track it.
  ///
  /// The way libdecaf handles this is to multiply by
  /// DECAF_448_EDDSA_DECODE_RATIO when decoding, and by
  /// DECAF_448_EDDSA_ENCODE_RATIO when encoding.  The product of these
  /// ratios is always exactly the cofactor 4, so the cofactor
  /// ends up cleared one way or another.  But exactly how that shakes
  /// out depends on the base points specified in RFC 8032.
  ///
  /// The upshot is that if you pass the Decaf/Ristretto base point to
  /// this function, you will get DECAF_448_EDDSA_ENCODE_RATIO times the
  /// EdDSA base point.
  ///
  /// @param [out] enc The encoded point.
  /// @param [in] p The point.
  void decaf_448_point_mul_by_ratio_and_encode_like_eddsa(
    ffi.Pointer<ffi.Uint8> enc,
    ffi.Pointer<decaf_448_point_t> p,
  ) {
    return _decaf_448_point_mul_by_ratio_and_encode_like_eddsa(
      enc,
      p,
    );
  }

  late final _decaf_448_point_mul_by_ratio_and_encode_like_eddsa_ptr = _lookup<
          ffi.NativeFunction<
              _c_decaf_448_point_mul_by_ratio_and_encode_like_eddsa>>(
      'decaf_448_point_mul_by_ratio_and_encode_like_eddsa');
  late final _dart_decaf_448_point_mul_by_ratio_and_encode_like_eddsa
      _decaf_448_point_mul_by_ratio_and_encode_like_eddsa =
      _decaf_448_point_mul_by_ratio_and_encode_like_eddsa_ptr.asFunction<
          _dart_decaf_448_point_mul_by_ratio_and_encode_like_eddsa>();

  /// @brief EdDSA point decoding.  Multiplies by DECAF_448_EDDSA_DECODE_RATIO,
  /// and ignores cofactor information.
  ///
  /// See notes on decaf_448_point_mul_by_ratio_and_encode_like_eddsa
  ///
  /// @param [out] enc The encoded point.
  /// @param [in] p The point.
  int decaf_448_point_decode_like_eddsa_and_mul_by_ratio(
    ffi.Pointer<decaf_448_point_t> p,
    ffi.Pointer<ffi.Uint8> enc,
  ) {
    return _decaf_448_point_decode_like_eddsa_and_mul_by_ratio(
      p,
      enc,
    );
  }

  late final _decaf_448_point_decode_like_eddsa_and_mul_by_ratio_ptr = _lookup<
          ffi.NativeFunction<
              _c_decaf_448_point_decode_like_eddsa_and_mul_by_ratio>>(
      'decaf_448_point_decode_like_eddsa_and_mul_by_ratio');
  late final _dart_decaf_448_point_decode_like_eddsa_and_mul_by_ratio
      _decaf_448_point_decode_like_eddsa_and_mul_by_ratio =
      _decaf_448_point_decode_like_eddsa_and_mul_by_ratio_ptr.asFunction<
          _dart_decaf_448_point_decode_like_eddsa_and_mul_by_ratio>();

  /// @brief EdDSA to ECDH public key conversion
  /// Deserialize the point to get y on Edwards curve,
  /// Convert it to u coordinate on Montgomery curve.
  ///
  /// @warning This function does not check that the public key being converted
  /// is a valid EdDSA public key (FUTURE?)
  ///
  /// @param[out] x The ECDH public key as in RFC7748(point on Montgomery curve)
  /// @param[in] ed The EdDSA public key(point on Edwards curve)
  void decaf_ed448_convert_public_key_to_x448(
    ffi.Pointer<ffi.Uint8> x,
    ffi.Pointer<ffi.Uint8> ed,
  ) {
    return _decaf_ed448_convert_public_key_to_x448(
      x,
      ed,
    );
  }

  late final _decaf_ed448_convert_public_key_to_x448_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_ed448_convert_public_key_to_x448>>(
          'decaf_ed448_convert_public_key_to_x448');
  late final _dart_decaf_ed448_convert_public_key_to_x448
      _decaf_ed448_convert_public_key_to_x448 =
      _decaf_ed448_convert_public_key_to_x448_ptr
          .asFunction<_dart_decaf_ed448_convert_public_key_to_x448>();

  /// @brief EdDSA to ECDH private key conversion
  /// Using the appropriate hash function, hash the EdDSA private key
  /// and keep only the lower bytes to get the ECDH private key
  ///
  /// @param[out] x The ECDH private key as in RFC7748
  /// @param[in] ed The EdDSA private key
  void decaf_ed448_convert_private_key_to_x448(
    ffi.Pointer<ffi.Uint8> x,
    ffi.Pointer<ffi.Uint8> ed,
  ) {
    return _decaf_ed448_convert_private_key_to_x448(
      x,
      ed,
    );
  }

  late final _decaf_ed448_convert_private_key_to_x448_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_ed448_convert_private_key_to_x448>>(
          'decaf_ed448_convert_private_key_to_x448');
  late final _dart_decaf_ed448_convert_private_key_to_x448
      _decaf_ed448_convert_private_key_to_x448 =
      _decaf_ed448_convert_private_key_to_x448_ptr
          .asFunction<_dart_decaf_ed448_convert_private_key_to_x448>();

  late final ffi.Pointer<ffi.Pointer<ffi.Uint8>> _DECAF_ED25519_NO_CONTEXT =
      _lookup<ffi.Pointer<ffi.Uint8>>('DECAF_ED25519_NO_CONTEXT');

  ffi.Pointer<ffi.Uint8> get DECAF_ED25519_NO_CONTEXT =>
      _DECAF_ED25519_NO_CONTEXT.value;

  set DECAF_ED25519_NO_CONTEXT(ffi.Pointer<ffi.Uint8> value) =>
      _DECAF_ED25519_NO_CONTEXT.value = value;

  /// @brief EdDSA key generation.  This function uses a different (non-Decaf)
  /// encoding.
  ///
  /// @param [out] pubkey The public key.
  /// @param [in] privkey The private key.
  void decaf_ed25519_derive_public_key(
    ffi.Pointer<ffi.Uint8> pubkey,
    ffi.Pointer<ffi.Uint8> privkey,
  ) {
    return _decaf_ed25519_derive_public_key(
      pubkey,
      privkey,
    );
  }

  late final _decaf_ed25519_derive_public_key_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_ed25519_derive_public_key>>(
          'decaf_ed25519_derive_public_key');
  late final _dart_decaf_ed25519_derive_public_key
      _decaf_ed25519_derive_public_key = _decaf_ed25519_derive_public_key_ptr
          .asFunction<_dart_decaf_ed25519_derive_public_key>();

  /// @brief EdDSA signing.
  ///
  /// @param [out] signature The signature.
  /// @param [in] privkey The private key.
  /// @param [in] pubkey The public key.
  /// @param [in] message The message to sign.
  /// @param [in] message_len The length of the message.
  /// @param [in] prehashed Nonzero if the message is actually the hash of something you want to sign.
  /// @param [in] context A "context" for this signature of up to 255 bytes.
  /// @param [in] context_len Length of the context.
  ///
  /// @warning For Ed25519, it is unsafe to use the same key for both prehashed and non-prehashed
  /// messages, at least without some very careful protocol-level disambiguation.  For Ed448 it is
  /// safe.  The C++ wrapper is designed to make it harder to screw this up, but this C code gives
  /// you no seat belt.
  void decaf_ed25519_sign(
    ffi.Pointer<ffi.Uint8> signature,
    ffi.Pointer<ffi.Uint8> privkey,
    ffi.Pointer<ffi.Uint8> pubkey,
    ffi.Pointer<ffi.Uint8> message,
    int message_len,
    int prehashed,
    ffi.Pointer<ffi.Uint8> context,
    int context_len,
  ) {
    return _decaf_ed25519_sign(
      signature,
      privkey,
      pubkey,
      message,
      message_len,
      prehashed,
      context,
      context_len,
    );
  }

  late final _decaf_ed25519_sign_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_ed25519_sign>>('decaf_ed25519_sign');
  late final _dart_decaf_ed25519_sign _decaf_ed25519_sign =
      _decaf_ed25519_sign_ptr.asFunction<_dart_decaf_ed25519_sign>();

  /// @brief EdDSA signing with prehash.
  ///
  /// @param [out] signature The signature.
  /// @param [in] privkey The private key.
  /// @param [in] pubkey The public key.
  /// @param [in] hash The hash of the message.  This object will not be modified by the call.
  /// @param [in] context A "context" for this signature of up to 255 bytes.  Must be the same as what was used for the prehash.
  /// @param [in] context_len Length of the context.
  ///
  /// @warning For Ed25519, it is unsafe to use the same key for both prehashed and non-prehashed
  /// messages, at least without some very careful protocol-level disambiguation.  For Ed448 it is
  /// safe.  The C++ wrapper is designed to make it harder to screw this up, but this C code gives
  /// you no seat belt.
  void decaf_ed25519_sign_prehash(
    ffi.Pointer<ffi.Uint8> signature,
    ffi.Pointer<ffi.Uint8> privkey,
    ffi.Pointer<ffi.Uint8> pubkey,
    ffi.Pointer<decaf_sha512_ctx_t> hash,
    ffi.Pointer<ffi.Uint8> context,
    int context_len,
  ) {
    return _decaf_ed25519_sign_prehash(
      signature,
      privkey,
      pubkey,
      hash,
      context,
      context_len,
    );
  }

  late final _decaf_ed25519_sign_prehash_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_ed25519_sign_prehash>>(
          'decaf_ed25519_sign_prehash');
  late final _dart_decaf_ed25519_sign_prehash _decaf_ed25519_sign_prehash =
      _decaf_ed25519_sign_prehash_ptr
          .asFunction<_dart_decaf_ed25519_sign_prehash>();

  /// @brief Prehash initialization, with contexts if supported.
  ///
  /// @param [out] hash The hash object to be initialized.
  void decaf_ed25519_prehash_init(
    ffi.Pointer<decaf_sha512_ctx_t> hash,
  ) {
    return _decaf_ed25519_prehash_init(
      hash,
    );
  }

  late final _decaf_ed25519_prehash_init_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_ed25519_prehash_init>>(
          'decaf_ed25519_prehash_init');
  late final _dart_decaf_ed25519_prehash_init _decaf_ed25519_prehash_init =
      _decaf_ed25519_prehash_init_ptr
          .asFunction<_dart_decaf_ed25519_prehash_init>();

  /// @brief EdDSA signature verification.
  ///
  /// Uses the standard (i.e. less-strict) verification formula.
  ///
  /// @param [in] signature The signature.
  /// @param [in] pubkey The public key.
  /// @param [in] message The message to verify.
  /// @param [in] message_len The length of the message.
  /// @param [in] prehashed Nonzero if the message is actually the hash of something you want to verify.
  /// @param [in] context A "context" for this signature of up to 255 bytes.
  /// @param [in] context_len Length of the context.
  ///
  /// @warning For Ed25519, it is unsafe to use the same key for both prehashed and non-prehashed
  /// messages, at least without some very careful protocol-level disambiguation.  For Ed448 it is
  /// safe.  The C++ wrapper is designed to make it harder to screw this up, but this C code gives
  /// you no seat belt.
  int decaf_ed25519_verify(
    ffi.Pointer<ffi.Uint8> signature,
    ffi.Pointer<ffi.Uint8> pubkey,
    ffi.Pointer<ffi.Uint8> message,
    int message_len,
    int prehashed,
    ffi.Pointer<ffi.Uint8> context,
    int context_len,
  ) {
    return _decaf_ed25519_verify(
      signature,
      pubkey,
      message,
      message_len,
      prehashed,
      context,
      context_len,
    );
  }

  late final _decaf_ed25519_verify_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_ed25519_verify>>(
          'decaf_ed25519_verify');
  late final _dart_decaf_ed25519_verify _decaf_ed25519_verify =
      _decaf_ed25519_verify_ptr.asFunction<_dart_decaf_ed25519_verify>();

  /// @brief EdDSA signature verification.
  ///
  /// Uses the standard (i.e. less-strict) verification formula.
  ///
  /// @param [in] signature The signature.
  /// @param [in] pubkey The public key.
  /// @param [in] hash The hash of the message.  This object will not be modified by the call.
  /// @param [in] context A "context" for this signature of up to 255 bytes.  Must be the same as what was used for the prehash.
  /// @param [in] context_len Length of the context.
  ///
  /// @warning For Ed25519, it is unsafe to use the same key for both prehashed and non-prehashed
  /// messages, at least without some very careful protocol-level disambiguation.  For Ed448 it is
  /// safe.  The C++ wrapper is designed to make it harder to screw this up, but this C code gives
  /// you no seat belt.
  int decaf_ed25519_verify_prehash(
    ffi.Pointer<ffi.Uint8> signature,
    ffi.Pointer<ffi.Uint8> pubkey,
    ffi.Pointer<decaf_sha512_ctx_t> hash,
    ffi.Pointer<ffi.Uint8> context,
    int context_len,
  ) {
    return _decaf_ed25519_verify_prehash(
      signature,
      pubkey,
      hash,
      context,
      context_len,
    );
  }

  late final _decaf_ed25519_verify_prehash_ptr =
      _lookup<ffi.NativeFunction<_c_decaf_ed25519_verify_prehash>>(
          'decaf_ed25519_verify_prehash');
  late final _dart_decaf_ed25519_verify_prehash _decaf_ed25519_verify_prehash =
      _decaf_ed25519_verify_prehash_ptr
          .asFunction<_dart_decaf_ed25519_verify_prehash>();

  /// @brief EdDSA point encoding.  Used internally, exposed externally.
  /// Multiplies by DECAF_255_EDDSA_ENCODE_RATIO first.
  ///
  /// The multiplication is required because the EdDSA encoding represents
  /// the cofactor information, but the Decaf encoding ignores it (which
  /// is the whole point).  So if you decode from EdDSA and re-encode to
  /// EdDSA, the cofactor info must get cleared, because the intermediate
  /// representation doesn't track it.
  ///
  /// The way libdecaf handles this is to multiply by
  /// DECAF_255_EDDSA_DECODE_RATIO when decoding, and by
  /// DECAF_255_EDDSA_ENCODE_RATIO when encoding.  The product of these
  /// ratios is always exactly the cofactor 8, so the cofactor
  /// ends up cleared one way or another.  But exactly how that shakes
  /// out depends on the base points specified in RFC 8032.
  ///
  /// The upshot is that if you pass the Decaf/Ristretto base point to
  /// this function, you will get DECAF_255_EDDSA_ENCODE_RATIO times the
  /// EdDSA base point.
  ///
  /// @param [out] enc The encoded point.
  /// @param [in] p The point.
  void decaf_255_point_mul_by_ratio_and_encode_like_eddsa(
    ffi.Pointer<ffi.Uint8> enc,
    ffi.Pointer<decaf_255_point_t> p,
  ) {
    return _decaf_255_point_mul_by_ratio_and_encode_like_eddsa(
      enc,
      p,
    );
  }

  late final _decaf_255_point_mul_by_ratio_and_encode_like_eddsa_ptr = _lookup<
          ffi.NativeFunction<
              _c_decaf_255_point_mul_by_ratio_and_encode_like_eddsa>>(
      'decaf_255_point_mul_by_ratio_and_encode_like_eddsa');
  late final _dart_decaf_255_point_mul_by_ratio_and_encode_like_eddsa
      _decaf_255_point_mul_by_ratio_and_encode_like_eddsa =
      _decaf_255_point_mul_by_ratio_and_encode_like_eddsa_ptr.asFunction<
          _dart_decaf_255_point_mul_by_ratio_and_encode_like_eddsa>();

  /// @brief EdDSA point decoding.  Multiplies by DECAF_255_EDDSA_DECODE_RATIO,
  /// and ignores cofactor information.
  ///
  /// See notes on decaf_255_point_mul_by_ratio_and_encode_like_eddsa
  ///
  /// @param [out] enc The encoded point.
  /// @param [in] p The point.
  int decaf_255_point_decode_like_eddsa_and_mul_by_ratio(
    ffi.Pointer<decaf_255_point_t> p,
    ffi.Pointer<ffi.Uint8> enc,
  ) {
    return _decaf_255_point_decode_like_eddsa_and_mul_by_ratio(
      p,
      enc,
    );
  }

  late final _decaf_255_point_decode_like_eddsa_and_mul_by_ratio_ptr = _lookup<
          ffi.NativeFunction<
              _c_decaf_255_point_decode_like_eddsa_and_mul_by_ratio>>(
      'decaf_255_point_decode_like_eddsa_and_mul_by_ratio');
  late final _dart_decaf_255_point_decode_like_eddsa_and_mul_by_ratio
      _decaf_255_point_decode_like_eddsa_and_mul_by_ratio =
      _decaf_255_point_decode_like_eddsa_and_mul_by_ratio_ptr.asFunction<
          _dart_decaf_255_point_decode_like_eddsa_and_mul_by_ratio>();

  /// @brief EdDSA to ECDH public key conversion
  /// Deserialize the point to get y on Edwards curve,
  /// Convert it to u coordinate on Montgomery curve.
  ///
  /// @warning This function does not check that the public key being converted
  /// is a valid EdDSA public key (FUTURE?)
  ///
  /// @param[out] x The ECDH public key as in RFC7748(point on Montgomery curve)
  /// @param[in] ed The EdDSA public key(point on Edwards curve)
  void decaf_ed25519_convert_public_key_to_x25519(
    ffi.Pointer<ffi.Uint8> x,
    ffi.Pointer<ffi.Uint8> ed,
  ) {
    return _decaf_ed25519_convert_public_key_to_x25519(
      x,
      ed,
    );
  }

  late final _decaf_ed25519_convert_public_key_to_x25519_ptr = _lookup<
          ffi.NativeFunction<_c_decaf_ed25519_convert_public_key_to_x25519>>(
      'decaf_ed25519_convert_public_key_to_x25519');
  late final _dart_decaf_ed25519_convert_public_key_to_x25519
      _decaf_ed25519_convert_public_key_to_x25519 =
      _decaf_ed25519_convert_public_key_to_x25519_ptr
          .asFunction<_dart_decaf_ed25519_convert_public_key_to_x25519>();

  /// @brief EdDSA to ECDH private key conversion
  /// Using the appropriate hash function, hash the EdDSA private key
  /// and keep only the lower bytes to get the ECDH private key
  ///
  /// @param[out] x The ECDH private key as in RFC7748
  /// @param[in] ed The EdDSA private key
  void decaf_ed25519_convert_private_key_to_x25519(
    ffi.Pointer<ffi.Uint8> x,
    ffi.Pointer<ffi.Uint8> ed,
  ) {
    return _decaf_ed25519_convert_private_key_to_x25519(
      x,
      ed,
    );
  }

  late final _decaf_ed25519_convert_private_key_to_x25519_ptr = _lookup<
          ffi.NativeFunction<_c_decaf_ed25519_convert_private_key_to_x25519>>(
      'decaf_ed25519_convert_private_key_to_x25519');
  late final _dart_decaf_ed25519_convert_private_key_to_x25519
      _decaf_ed25519_convert_private_key_to_x25519 =
      _decaf_ed25519_convert_private_key_to_x25519_ptr
          .asFunction<_dart_decaf_ed25519_convert_private_key_to_x25519>();
}

class __fsid_t extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Int32> __val;
}

class __sigset_t extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint64> __val;
}

class timeval extends ffi.Struct {
  @ffi.Int64()
  external int tv_sec;

  @ffi.Int64()
  external int tv_usec;
}

class timespec extends ffi.Struct {
  @ffi.Int64()
  external int tv_sec;

  @ffi.Int64()
  external int tv_nsec;
}

class fd_set extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Int64> __fds_bits;
}

class __pthread_list_t extends ffi.Struct {
  external ffi.Pointer<__pthread_list_t> __prev;

  external ffi.Pointer<__pthread_list_t> __next;
}

class __pthread_slist_t extends ffi.Struct {
  external ffi.Pointer<__pthread_slist_t> __next;
}

class __pthread_mutex_s extends ffi.Struct {
  @ffi.Int32()
  external int __lock;

  @ffi.Uint32()
  external int __count;

  @ffi.Int32()
  external int __owner;

  @ffi.Uint32()
  external int __nusers;

  @ffi.Int32()
  external int __kind;

  @ffi.Int16()
  external int __spins;

  @ffi.Int16()
  external int __elision;

  external __pthread_list_t __list;
}

class __pthread_rwlock_arch_t extends ffi.Struct {
  @ffi.Uint32()
  external int __readers;

  @ffi.Uint32()
  external int __writers;

  @ffi.Uint32()
  external int __wrphase_futex;

  @ffi.Uint32()
  external int __writers_futex;

  @ffi.Uint32()
  external int __pad3;

  @ffi.Uint32()
  external int __pad4;

  @ffi.Int32()
  external int __cur_writer;

  @ffi.Int32()
  external int __shared;

  @ffi.Int8()
  external int __rwelision;

  @ffi.Array.multi([7])
  external ffi.Array<ffi.Uint8> __pad1;

  @ffi.Uint64()
  external int __pad2;

  @ffi.Uint32()
  external int __flags;
}

class __pthread_cond_s extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Uint32> __g_refs;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Uint32> __g_size;

  @ffi.Uint32()
  external int __g1_orig_size;

  @ffi.Uint32()
  external int __wrefs;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Uint32> __g_signals;
}

abstract class idtype_t {
  static const int P_ALL = 0;
  static const int P_PID = 1;
  static const int P_PGID = 2;
}

class div_t extends ffi.Struct {
  @ffi.Int32()
  external int quot;

  @ffi.Int32()
  external int rem;
}

class ldiv_t extends ffi.Struct {
  @ffi.Int64()
  external int quot;

  @ffi.Int64()
  external int rem;
}

class lldiv_t extends ffi.Struct {
  @ffi.Int64()
  external int quot;

  @ffi.Int64()
  external int rem;
}

class random_data extends ffi.Struct {
  external ffi.Pointer<ffi.Int32> fptr;

  external ffi.Pointer<ffi.Int32> rptr;

  external ffi.Pointer<ffi.Int32> state;

  @ffi.Int32()
  external int rand_type;

  @ffi.Int32()
  external int rand_deg;

  @ffi.Int32()
  external int rand_sep;

  external ffi.Pointer<ffi.Int32> end_ptr;
}

class drand48_data extends ffi.Struct {
  @ffi.Array.multi([3])
  external ffi.Array<ffi.Uint16> __x;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.Uint16> __old_x;

  @ffi.Uint16()
  external int __c;

  @ffi.Uint16()
  external int __init;

  @ffi.Uint64()
  external int __a;
}

/// Another boolean type used to indicate success or failure.
abstract class decaf_error_t {
  /// < The operation succeeded.
  static const int DECAF_SUCCESS = -1;

  /// < The operation failed.
  static const int DECAF_FAILURE = 0;
}

/// Hash context for SHA-512
class decaf_sha512_ctx_t extends ffi.Struct {
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Uint64> state;

  @ffi.Array.multi([128])
  external ffi.Array<ffi.Uint8> block;

  @ffi.Uint64()
  external int bytes_processed;
}

/// @brief Galois field element internal structure
class gf_448_t extends ffi.Struct {
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Uint64> limb;
}

/// Representation of a point on the elliptic curve.
class decaf_448_point_t extends ffi.Struct {
  @ffi.Array.multi([1])
  external ffi.Array<gf_448_t> x;

  @ffi.Array.multi([1])
  external ffi.Array<gf_448_t> y;

  @ffi.Array.multi([1])
  external ffi.Array<gf_448_t> z;

  @ffi.Array.multi([1])
  external ffi.Array<gf_448_t> t;
}

/// Precomputed table based on a point.  Can be trivial implementation.
class decaf_448_precomputed_s extends ffi.Opaque {}

/// Representation of an element of the scalar field.
class decaf_448_scalar_t extends ffi.Struct {
  @ffi.Array.multi([7])
  external ffi.Array<ffi.Uint64> limb;
}

/// @brief Galois field element internal structure
class gf_25519_t extends ffi.Struct {
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint64> limb;
}

/// Representation of a point on the elliptic curve.
class decaf_255_point_t extends ffi.Struct {
  @ffi.Array.multi([1])
  external ffi.Array<gf_25519_t> x;

  @ffi.Array.multi([1])
  external ffi.Array<gf_25519_t> y;

  @ffi.Array.multi([1])
  external ffi.Array<gf_25519_t> z;

  @ffi.Array.multi([1])
  external ffi.Array<gf_25519_t> t;
}

/// Precomputed table based on a point.  Can be trivial implementation.
class decaf_255_precomputed_s extends ffi.Opaque {}

/// Representation of an element of the scalar field.
class decaf_255_scalar_t extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Uint64> limb;
}

/// Sponge container object for the various primitives.
class decaf_keccak_sponge_s extends ffi.Struct {
  @ffi.Array.multi([26])
  external ffi.Array<ffi.Uint64> opaque;
}

/// Parameters for sponge construction, distinguishing DECAF_SHA3 and
/// DECAF_SHAKE instances.
class decaf_kparams_s extends ffi.Opaque {}

class decaf_shake128_ctx_t extends ffi.Struct {
  @ffi.Array.multi([1])
  external ffi.Array<decaf_keccak_sponge_s> s;
}

class decaf_shake256_ctx_t extends ffi.Struct {
  @ffi.Array.multi([1])
  external ffi.Array<decaf_keccak_sponge_s> s;
}

class decaf_sha3_224_ctx_t extends ffi.Struct {
  @ffi.Array.multi([1])
  external ffi.Array<decaf_keccak_sponge_s> s;
}

class decaf_sha3_256_ctx_t extends ffi.Struct {
  @ffi.Array.multi([1])
  external ffi.Array<decaf_keccak_sponge_s> s;
}

class decaf_sha3_384_ctx_t extends ffi.Struct {
  @ffi.Array.multi([1])
  external ffi.Array<decaf_keccak_sponge_s> s;
}

class decaf_sha3_512_ctx_t extends ffi.Struct {
  @ffi.Array.multi([1])
  external ffi.Array<decaf_keccak_sponge_s> s;
}

/// Keccak CSPRNG structure as struct.
class decaf_keccak_prng_s extends ffi.Struct {
  @ffi.Array.multi([1])
  external ffi.Array<decaf_keccak_sponge_s> sponge;
}

const int _STDINT_H = 1;

const int _FEATURES_H = 1;

const int _DEFAULT_SOURCE = 1;

const int __GLIBC_USE_ISOC2X = 1;

const int __USE_ISOC11 = 1;

const int __USE_ISOC99 = 1;

const int __USE_ISOC95 = 1;

const int _POSIX_SOURCE = 1;

const int _POSIX_C_SOURCE = 200809;

const int __USE_POSIX = 1;

const int __USE_POSIX2 = 1;

const int __USE_POSIX199309 = 1;

const int __USE_POSIX199506 = 1;

const int __USE_XOPEN2K = 1;

const int __USE_XOPEN2K8 = 1;

const int _ATFILE_SOURCE = 1;

const int __USE_MISC = 1;

const int __USE_ATFILE = 1;

const int __USE_FORTIFY_LEVEL = 0;

const int __GLIBC_USE_DEPRECATED_GETS = 0;

const int __GLIBC_USE_DEPRECATED_SCANF = 0;

const int _STDC_PREDEF_H = 1;

const int __STDC_IEC_559__ = 1;

const int __STDC_IEC_559_COMPLEX__ = 1;

const int __STDC_ISO_10646__ = 201706;

const int __GNU_LIBRARY__ = 6;

const int __GLIBC__ = 2;

const int __GLIBC_MINOR__ = 31;

const int _SYS_CDEFS_H = 1;

const int __glibc_c99_flexarr_available = 1;

const int __WORDSIZE = 64;

const int __WORDSIZE_TIME64_COMPAT32 = 1;

const int __SYSCALL_WORDSIZE = 64;

const int __LONG_DOUBLE_USES_FLOAT128 = 0;

const int __HAVE_GENERIC_SELECTION = 0;

const int __GLIBC_USE_LIB_EXT2 = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_TYPES_EXT = 1;

const int _BITS_TYPES_H = 1;

const int __TIMESIZE = 64;

const int _BITS_TYPESIZES_H = 1;

const int __OFF_T_MATCHES_OFF64_T = 1;

const int __INO_T_MATCHES_INO64_T = 1;

const int __RLIM_T_MATCHES_RLIM64_T = 1;

const int __STATFS_MATCHES_STATFS64 = 1;

const int __FD_SETSIZE = 1024;

const int _BITS_TIME64_H = 1;

const int _BITS_WCHAR_H = 1;

const int __WCHAR_MAX = 2147483647;

const int __WCHAR_MIN = -2147483648;

const int _BITS_STDINT_INTN_H = 1;

const int _BITS_STDINT_UINTN_H = 1;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -9223372036854775808;

const int INT_FAST32_MIN = -9223372036854775808;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 9223372036854775807;

const int INT_FAST32_MAX = 9223372036854775807;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = -1;

const int UINT_FAST32_MAX = -1;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int SIZE_MAX = -1;

const int WCHAR_MIN = -2147483648;

const int WCHAR_MAX = 2147483647;

const int WINT_MIN = 0;

const int WINT_MAX = 4294967295;

const int _SYS_TYPES_H = 1;

const int __clock_t_defined = 1;

const int __clockid_t_defined = 1;

const int __time_t_defined = 1;

const int __timer_t_defined = 1;

const int __BIT_TYPES_DEFINED__ = 1;

const int _ENDIAN_H = 1;

const int _BITS_ENDIAN_H = 1;

const int __LITTLE_ENDIAN = 1234;

const int __BIG_ENDIAN = 4321;

const int __PDP_ENDIAN = 3412;

const int _BITS_ENDIANNESS_H = 1;

const int __BYTE_ORDER = 1234;

const int __FLOAT_WORD_ORDER = 1234;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int BYTE_ORDER = 1234;

const int _BITS_BYTESWAP_H = 1;

const int _BITS_UINTN_IDENTITY_H = 1;

const int _SYS_SELECT_H = 1;

const String __FD_ZERO_STOS = 'stosq';

const int __sigset_t_defined = 1;

const int _SIGSET_NWORDS = 16;

const int __timeval_defined = 1;

const int _STRUCT_TIMESPEC = 1;

const int __NFDBITS = 64;

const int FD_SETSIZE = 1024;

const int NFDBITS = 64;

const int _BITS_PTHREADTYPES_COMMON_H = 1;

const int _THREAD_SHARED_TYPES_H = 1;

const int _BITS_PTHREADTYPES_ARCH_H = 1;

const int __SIZEOF_PTHREAD_MUTEX_T = 40;

const int __SIZEOF_PTHREAD_ATTR_T = 56;

const int __SIZEOF_PTHREAD_RWLOCK_T = 56;

const int __SIZEOF_PTHREAD_BARRIER_T = 32;

const int __SIZEOF_PTHREAD_MUTEXATTR_T = 4;

const int __SIZEOF_PTHREAD_COND_T = 48;

const int __SIZEOF_PTHREAD_CONDATTR_T = 4;

const int __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;

const int __SIZEOF_PTHREAD_BARRIERATTR_T = 4;

const int _THREAD_MUTEX_INTERNAL_H = 1;

const int __PTHREAD_MUTEX_HAVE_PREV = 1;

const int __PTHREAD_RWLOCK_ELISION_EXTRA = 0;

const int __have_pthread_attr_t = 1;

const int NULL = 0;

const int _STDLIB_H = 1;

const int WNOHANG = 1;

const int WUNTRACED = 2;

const int WSTOPPED = 2;

const int WEXITED = 4;

const int WCONTINUED = 8;

const int WNOWAIT = 16777216;

const int __WNOTHREAD = 536870912;

const int __WALL = 1073741824;

const int __WCLONE = 2147483648;

const int __ENUM_IDTYPE_T = 1;

const int __W_CONTINUED = 65535;

const int __WCOREFLAG = 128;

const int __HAVE_FLOAT128 = 0;

const int __HAVE_DISTINCT_FLOAT128 = 0;

const int __HAVE_FLOAT64X = 1;

const int __HAVE_FLOAT64X_LONG_DOUBLE = 1;

const int __HAVE_FLOAT16 = 0;

const int __HAVE_FLOAT32 = 1;

const int __HAVE_FLOAT64 = 1;

const int __HAVE_FLOAT32X = 1;

const int __HAVE_FLOAT128X = 0;

const int __HAVE_DISTINCT_FLOAT16 = 0;

const int __HAVE_DISTINCT_FLOAT32 = 0;

const int __HAVE_DISTINCT_FLOAT64 = 0;

const int __HAVE_DISTINCT_FLOAT32X = 0;

const int __HAVE_DISTINCT_FLOAT64X = 0;

const int __HAVE_DISTINCT_FLOAT128X = 0;

const int __HAVE_FLOAT128_UNLIKE_LDBL = 0;

const int __HAVE_FLOATN_NOT_TYPEDEF = 0;

const int __ldiv_t_defined = 1;

const int __lldiv_t_defined = 1;

const int RAND_MAX = 2147483647;

const int EXIT_FAILURE = 1;

const int EXIT_SUCCESS = 0;

const int _ALLOCA_H = 1;

const int __DECAF_COMMON_H__ = 1;

const int DECAF_WORD_BITS = 64;

const int __DECAF_POINT_448_H__ = 1;

const int DECAF_448_SCALAR_LIMBS = 7;

const int DECAF_448_SCALAR_BITS = 446;

const int __DECAF_448_GF_DEFINED__ = 1;

const int DECAF_448_SER_BYTES = 56;

const int DECAF_448_HASH_BYTES = 56;

const int DECAF_448_SCALAR_BYTES = 56;

const int DECAF_448_INVERT_ELLIGATOR_WHICH_BITS = 3;

const int DECAF_448_REMOVED_COFACTOR = 4;

const int DECAF_X448_ENCODE_RATIO = 2;

const int DECAF_X448_PUBLIC_BYTES = 56;

const int DECAF_X448_PRIVATE_BYTES = 56;

const int __DECAF_POINT_255_H__ = 1;

const int DECAF_255_SCALAR_LIMBS = 4;

const int DECAF_255_SCALAR_BITS = 253;

const int __DECAF_25519_GF_DEFINED__ = 1;

const int DECAF_255_SER_BYTES = 32;

const int DECAF_255_HASH_BYTES = 32;

const int DECAF_255_SCALAR_BYTES = 32;

const int DECAF_255_INVERT_ELLIGATOR_WHICH_BITS = 5;

const int DECAF_255_REMOVED_COFACTOR = 8;

const int DECAF_X25519_ENCODE_RATIO = 4;

const int DECAF_X25519_PUBLIC_BYTES = 32;

const int DECAF_X25519_PRIVATE_BYTES = 32;

const int __DECAF_ED448_H__ = 1;

const int DECAF_EDDSA_448_PUBLIC_BYTES = 57;

const int DECAF_EDDSA_448_PRIVATE_BYTES = 57;

const int DECAF_EDDSA_448_SIGNATURE_BYTES = 114;

const int DECAF_EDDSA_448_SUPPORTS_CONTEXTLESS_SIGS = 0;

const int DECAF_448_EDDSA_ENCODE_RATIO = 4;

const int DECAF_448_EDDSA_DECODE_RATIO = 1;

const int __DECAF_ED255_H__ = 1;

const int DECAF_EDDSA_25519_PUBLIC_BYTES = 32;

const int DECAF_EDDSA_25519_PRIVATE_BYTES = 32;

const int DECAF_EDDSA_25519_SIGNATURE_BYTES = 64;

const int DECAF_EDDSA_25519_SUPPORTS_CONTEXTLESS_SIGS = 1;

const int DECAF_255_EDDSA_ENCODE_RATIO = 4;

const int DECAF_255_EDDSA_DECODE_RATIO = 2;

const int __DECAF_H__ = 1;

typedef _c_select = ffi.Int32 Function(
  ffi.Int32 __nfds,
  ffi.Pointer<fd_set> __readfds,
  ffi.Pointer<fd_set> __writefds,
  ffi.Pointer<fd_set> __exceptfds,
  ffi.Pointer<timeval> __timeout,
);

typedef _dart_select = int Function(
  int __nfds,
  ffi.Pointer<fd_set> __readfds,
  ffi.Pointer<fd_set> __writefds,
  ffi.Pointer<fd_set> __exceptfds,
  ffi.Pointer<timeval> __timeout,
);

typedef _c_pselect = ffi.Int32 Function(
  ffi.Int32 __nfds,
  ffi.Pointer<fd_set> __readfds,
  ffi.Pointer<fd_set> __writefds,
  ffi.Pointer<fd_set> __exceptfds,
  ffi.Pointer<timespec> __timeout,
  ffi.Pointer<__sigset_t> __sigmask,
);

typedef _dart_pselect = int Function(
  int __nfds,
  ffi.Pointer<fd_set> __readfds,
  ffi.Pointer<fd_set> __writefds,
  ffi.Pointer<fd_set> __exceptfds,
  ffi.Pointer<timespec> __timeout,
  ffi.Pointer<__sigset_t> __sigmask,
);

typedef _c___ctype_get_mb_cur_max = ffi.Uint64 Function();

typedef _dart___ctype_get_mb_cur_max = int Function();

typedef _c_atof = ffi.Double Function(
  ffi.Pointer<ffi.Int8> __nptr,
);

typedef _dart_atof = double Function(
  ffi.Pointer<ffi.Int8> __nptr,
);

typedef _c_atoi = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __nptr,
);

typedef _dart_atoi = int Function(
  ffi.Pointer<ffi.Int8> __nptr,
);

typedef _c_atol = ffi.Int64 Function(
  ffi.Pointer<ffi.Int8> __nptr,
);

typedef _dart_atol = int Function(
  ffi.Pointer<ffi.Int8> __nptr,
);

typedef _c_atoll = ffi.Int64 Function(
  ffi.Pointer<ffi.Int8> __nptr,
);

typedef _dart_atoll = int Function(
  ffi.Pointer<ffi.Int8> __nptr,
);

typedef _c_strtod = ffi.Double Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
);

typedef _dart_strtod = double Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
);

typedef _c_strtof = ffi.Float Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
);

typedef _dart_strtof = double Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
);

typedef _c_strtol = ffi.Int64 Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  ffi.Int32 __base,
);

typedef _dart_strtol = int Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  int __base,
);

typedef _c_strtoul = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  ffi.Int32 __base,
);

typedef _dart_strtoul = int Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  int __base,
);

typedef _c_strtoq = ffi.Int64 Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  ffi.Int32 __base,
);

typedef _dart_strtoq = int Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  int __base,
);

typedef _c_strtouq = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  ffi.Int32 __base,
);

typedef _dart_strtouq = int Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  int __base,
);

typedef _c_strtoll = ffi.Int64 Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  ffi.Int32 __base,
);

typedef _dart_strtoll = int Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  int __base,
);

typedef _c_strtoull = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  ffi.Int32 __base,
);

typedef _dart_strtoull = int Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  int __base,
);

typedef _c_l64a = ffi.Pointer<ffi.Int8> Function(
  ffi.Int64 __n,
);

typedef _dart_l64a = ffi.Pointer<ffi.Int8> Function(
  int __n,
);

typedef _c_a64l = ffi.Int64 Function(
  ffi.Pointer<ffi.Int8> __s,
);

typedef _dart_a64l = int Function(
  ffi.Pointer<ffi.Int8> __s,
);

typedef _c_random = ffi.Int64 Function();

typedef _dart_random = int Function();

typedef _c_srandom = ffi.Void Function(
  ffi.Uint32 __seed,
);

typedef _dart_srandom = void Function(
  int __seed,
);

typedef _c_initstate = ffi.Pointer<ffi.Int8> Function(
  ffi.Uint32 __seed,
  ffi.Pointer<ffi.Int8> __statebuf,
  ffi.Uint64 __statelen,
);

typedef _dart_initstate = ffi.Pointer<ffi.Int8> Function(
  int __seed,
  ffi.Pointer<ffi.Int8> __statebuf,
  int __statelen,
);

typedef _c_setstate = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __statebuf,
);

typedef _dart_setstate = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __statebuf,
);

typedef _c_random_r = ffi.Int32 Function(
  ffi.Pointer<random_data> __buf,
  ffi.Pointer<ffi.Int32> __result,
);

typedef _dart_random_r = int Function(
  ffi.Pointer<random_data> __buf,
  ffi.Pointer<ffi.Int32> __result,
);

typedef _c_srandom_r = ffi.Int32 Function(
  ffi.Uint32 __seed,
  ffi.Pointer<random_data> __buf,
);

typedef _dart_srandom_r = int Function(
  int __seed,
  ffi.Pointer<random_data> __buf,
);

typedef _c_initstate_r = ffi.Int32 Function(
  ffi.Uint32 __seed,
  ffi.Pointer<ffi.Int8> __statebuf,
  ffi.Uint64 __statelen,
  ffi.Pointer<random_data> __buf,
);

typedef _dart_initstate_r = int Function(
  int __seed,
  ffi.Pointer<ffi.Int8> __statebuf,
  int __statelen,
  ffi.Pointer<random_data> __buf,
);

typedef _c_setstate_r = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __statebuf,
  ffi.Pointer<random_data> __buf,
);

typedef _dart_setstate_r = int Function(
  ffi.Pointer<ffi.Int8> __statebuf,
  ffi.Pointer<random_data> __buf,
);

typedef _c_rand = ffi.Int32 Function();

typedef _dart_rand = int Function();

typedef _c_srand = ffi.Void Function(
  ffi.Uint32 __seed,
);

typedef _dart_srand = void Function(
  int __seed,
);

typedef _c_rand_r = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint32> __seed,
);

typedef _dart_rand_r = int Function(
  ffi.Pointer<ffi.Uint32> __seed,
);

typedef _c_drand48 = ffi.Double Function();

typedef _dart_drand48 = double Function();

typedef _c_erand48 = ffi.Double Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
);

typedef _dart_erand48 = double Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
);

typedef _c_lrand48 = ffi.Int64 Function();

typedef _dart_lrand48 = int Function();

typedef _c_nrand48 = ffi.Int64 Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
);

typedef _dart_nrand48 = int Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
);

typedef _c_mrand48 = ffi.Int64 Function();

typedef _dart_mrand48 = int Function();

typedef _c_jrand48 = ffi.Int64 Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
);

typedef _dart_jrand48 = int Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
);

typedef _c_srand48 = ffi.Void Function(
  ffi.Int64 __seedval,
);

typedef _dart_srand48 = void Function(
  int __seedval,
);

typedef _c_seed48 = ffi.Pointer<ffi.Uint16> Function(
  ffi.Pointer<ffi.Uint16> __seed16v,
);

typedef _dart_seed48 = ffi.Pointer<ffi.Uint16> Function(
  ffi.Pointer<ffi.Uint16> __seed16v,
);

typedef _c_lcong48 = ffi.Void Function(
  ffi.Pointer<ffi.Uint16> __param,
);

typedef _dart_lcong48 = void Function(
  ffi.Pointer<ffi.Uint16> __param,
);

typedef _c_drand48_r = ffi.Int32 Function(
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Double> __result,
);

typedef _dart_drand48_r = int Function(
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Double> __result,
);

typedef _c_erand48_r = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Double> __result,
);

typedef _dart_erand48_r = int Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Double> __result,
);

typedef _c_lrand48_r = ffi.Int32 Function(
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Int64> __result,
);

typedef _dart_lrand48_r = int Function(
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Int64> __result,
);

typedef _c_nrand48_r = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Int64> __result,
);

typedef _dart_nrand48_r = int Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Int64> __result,
);

typedef _c_mrand48_r = ffi.Int32 Function(
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Int64> __result,
);

typedef _dart_mrand48_r = int Function(
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Int64> __result,
);

typedef _c_jrand48_r = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Int64> __result,
);

typedef _dart_jrand48_r = int Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Int64> __result,
);

typedef _c_srand48_r = ffi.Int32 Function(
  ffi.Int64 __seedval,
  ffi.Pointer<drand48_data> __buffer,
);

typedef _dart_srand48_r = int Function(
  int __seedval,
  ffi.Pointer<drand48_data> __buffer,
);

typedef _c_seed48_r = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint16> __seed16v,
  ffi.Pointer<drand48_data> __buffer,
);

typedef _dart_seed48_r = int Function(
  ffi.Pointer<ffi.Uint16> __seed16v,
  ffi.Pointer<drand48_data> __buffer,
);

typedef _c_lcong48_r = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint16> __param,
  ffi.Pointer<drand48_data> __buffer,
);

typedef _dart_lcong48_r = int Function(
  ffi.Pointer<ffi.Uint16> __param,
  ffi.Pointer<drand48_data> __buffer,
);

typedef _c_malloc = ffi.Pointer<ffi.Void> Function(
  ffi.Uint64 __size,
);

typedef _dart_malloc = ffi.Pointer<ffi.Void> Function(
  int __size,
);

typedef _c_calloc = ffi.Pointer<ffi.Void> Function(
  ffi.Uint64 __nmemb,
  ffi.Uint64 __size,
);

typedef _dart_calloc = ffi.Pointer<ffi.Void> Function(
  int __nmemb,
  int __size,
);

typedef _c_realloc = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> __ptr,
  ffi.Uint64 __size,
);

typedef _dart_realloc = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> __ptr,
  int __size,
);

typedef _c_reallocarray = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> __ptr,
  ffi.Uint64 __nmemb,
  ffi.Uint64 __size,
);

typedef _dart_reallocarray = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> __ptr,
  int __nmemb,
  int __size,
);

typedef _c_free = ffi.Void Function(
  ffi.Pointer<ffi.Void> __ptr,
);

typedef _dart_free = void Function(
  ffi.Pointer<ffi.Void> __ptr,
);

typedef _c_alloca = ffi.Pointer<ffi.Void> Function(
  ffi.Uint64 __size,
);

typedef _dart_alloca = ffi.Pointer<ffi.Void> Function(
  int __size,
);

typedef _c_valloc = ffi.Pointer<ffi.Void> Function(
  ffi.Uint64 __size,
);

typedef _dart_valloc = ffi.Pointer<ffi.Void> Function(
  int __size,
);

typedef _c_posix_memalign = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> __memptr,
  ffi.Uint64 __alignment,
  ffi.Uint64 __size,
);

typedef _dart_posix_memalign = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> __memptr,
  int __alignment,
  int __size,
);

typedef _c_aligned_alloc = ffi.Pointer<ffi.Void> Function(
  ffi.Uint64 __alignment,
  ffi.Uint64 __size,
);

typedef _dart_aligned_alloc = ffi.Pointer<ffi.Void> Function(
  int __alignment,
  int __size,
);

typedef _c_abort = ffi.Void Function();

typedef _dart_abort = void Function();

typedef _typedefC_1 = ffi.Void Function();

typedef _c_atexit = ffi.Int32 Function(
  ffi.Pointer<ffi.NativeFunction<_typedefC_1>> __func,
);

typedef _dart_atexit = int Function(
  ffi.Pointer<ffi.NativeFunction<_typedefC_1>> __func,
);

typedef _typedefC_2 = ffi.Void Function();

typedef _c_at_quick_exit = ffi.Int32 Function(
  ffi.Pointer<ffi.NativeFunction<_typedefC_2>> __func,
);

typedef _dart_at_quick_exit = int Function(
  ffi.Pointer<ffi.NativeFunction<_typedefC_2>> __func,
);

typedef _typedefC_3 = ffi.Void Function(
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);

typedef _c_on_exit = ffi.Int32 Function(
  ffi.Pointer<ffi.NativeFunction<_typedefC_3>> __func,
  ffi.Pointer<ffi.Void> __arg,
);

typedef _dart_on_exit = int Function(
  ffi.Pointer<ffi.NativeFunction<_typedefC_3>> __func,
  ffi.Pointer<ffi.Void> __arg,
);

typedef _c_exit = ffi.Void Function(
  ffi.Int32 __status,
);

typedef _dart_exit = void Function(
  int __status,
);

typedef _c_quick_exit = ffi.Void Function(
  ffi.Int32 __status,
);

typedef _dart_quick_exit = void Function(
  int __status,
);

typedef _c__Exit = ffi.Void Function(
  ffi.Int32 __status,
);

typedef _dart__Exit = void Function(
  int __status,
);

typedef _c_getenv = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __name,
);

typedef _dart_getenv = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __name,
);

typedef _c_putenv = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __string,
);

typedef _dart_putenv = int Function(
  ffi.Pointer<ffi.Int8> __string,
);

typedef _c_setenv = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __name,
  ffi.Pointer<ffi.Int8> __value,
  ffi.Int32 __replace,
);

typedef _dart_setenv = int Function(
  ffi.Pointer<ffi.Int8> __name,
  ffi.Pointer<ffi.Int8> __value,
  int __replace,
);

typedef _c_unsetenv = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __name,
);

typedef _dart_unsetenv = int Function(
  ffi.Pointer<ffi.Int8> __name,
);

typedef _c_clearenv = ffi.Int32 Function();

typedef _dart_clearenv = int Function();

typedef _c_mktemp = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __template,
);

typedef _dart_mktemp = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __template,
);

typedef _c_mkstemp = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __template,
);

typedef _dart_mkstemp = int Function(
  ffi.Pointer<ffi.Int8> __template,
);

typedef _c_mkstemps = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __template,
  ffi.Int32 __suffixlen,
);

typedef _dart_mkstemps = int Function(
  ffi.Pointer<ffi.Int8> __template,
  int __suffixlen,
);

typedef _c_mkdtemp = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __template,
);

typedef _dart_mkdtemp = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __template,
);

typedef _c_system = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __command,
);

typedef _dart_system = int Function(
  ffi.Pointer<ffi.Int8> __command,
);

typedef _c_realpath = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __name,
  ffi.Pointer<ffi.Int8> __resolved,
);

typedef _dart_realpath = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __name,
  ffi.Pointer<ffi.Int8> __resolved,
);

typedef __compar_fn_t = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_bsearch = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> __key,
  ffi.Pointer<ffi.Void> __base,
  ffi.Uint64 __nmemb,
  ffi.Uint64 __size,
  ffi.Pointer<ffi.NativeFunction<__compar_fn_t>> __compar,
);

typedef _dart_bsearch = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> __key,
  ffi.Pointer<ffi.Void> __base,
  int __nmemb,
  int __size,
  ffi.Pointer<ffi.NativeFunction<__compar_fn_t>> __compar,
);

typedef _c_qsort = ffi.Void Function(
  ffi.Pointer<ffi.Void> __base,
  ffi.Uint64 __nmemb,
  ffi.Uint64 __size,
  ffi.Pointer<ffi.NativeFunction<__compar_fn_t>> __compar,
);

typedef _dart_qsort = void Function(
  ffi.Pointer<ffi.Void> __base,
  int __nmemb,
  int __size,
  ffi.Pointer<ffi.NativeFunction<__compar_fn_t>> __compar,
);

typedef _c_abs = ffi.Int32 Function(
  ffi.Int32 __x,
);

typedef _dart_abs = int Function(
  int __x,
);

typedef _c_labs = ffi.Int64 Function(
  ffi.Int64 __x,
);

typedef _dart_labs = int Function(
  int __x,
);

typedef _c_llabs = ffi.Int64 Function(
  ffi.Int64 __x,
);

typedef _dart_llabs = int Function(
  int __x,
);

typedef _c_div = div_t Function(
  ffi.Int32 __numer,
  ffi.Int32 __denom,
);

typedef _dart_div = div_t Function(
  int __numer,
  int __denom,
);

typedef _c_ldiv = ldiv_t Function(
  ffi.Int64 __numer,
  ffi.Int64 __denom,
);

typedef _dart_ldiv = ldiv_t Function(
  int __numer,
  int __denom,
);

typedef _c_lldiv = lldiv_t Function(
  ffi.Int64 __numer,
  ffi.Int64 __denom,
);

typedef _dart_lldiv = lldiv_t Function(
  int __numer,
  int __denom,
);

typedef _c_ecvt = ffi.Pointer<ffi.Int8> Function(
  ffi.Double __value,
  ffi.Int32 __ndigit,
  ffi.Pointer<ffi.Int32> __decpt,
  ffi.Pointer<ffi.Int32> __sign,
);

typedef _dart_ecvt = ffi.Pointer<ffi.Int8> Function(
  double __value,
  int __ndigit,
  ffi.Pointer<ffi.Int32> __decpt,
  ffi.Pointer<ffi.Int32> __sign,
);

typedef _c_fcvt = ffi.Pointer<ffi.Int8> Function(
  ffi.Double __value,
  ffi.Int32 __ndigit,
  ffi.Pointer<ffi.Int32> __decpt,
  ffi.Pointer<ffi.Int32> __sign,
);

typedef _dart_fcvt = ffi.Pointer<ffi.Int8> Function(
  double __value,
  int __ndigit,
  ffi.Pointer<ffi.Int32> __decpt,
  ffi.Pointer<ffi.Int32> __sign,
);

typedef _c_gcvt = ffi.Pointer<ffi.Int8> Function(
  ffi.Double __value,
  ffi.Int32 __ndigit,
  ffi.Pointer<ffi.Int8> __buf,
);

typedef _dart_gcvt = ffi.Pointer<ffi.Int8> Function(
  double __value,
  int __ndigit,
  ffi.Pointer<ffi.Int8> __buf,
);

typedef _c_ecvt_r = ffi.Int32 Function(
  ffi.Double __value,
  ffi.Int32 __ndigit,
  ffi.Pointer<ffi.Int32> __decpt,
  ffi.Pointer<ffi.Int32> __sign,
  ffi.Pointer<ffi.Int8> __buf,
  ffi.Uint64 __len,
);

typedef _dart_ecvt_r = int Function(
  double __value,
  int __ndigit,
  ffi.Pointer<ffi.Int32> __decpt,
  ffi.Pointer<ffi.Int32> __sign,
  ffi.Pointer<ffi.Int8> __buf,
  int __len,
);

typedef _c_fcvt_r = ffi.Int32 Function(
  ffi.Double __value,
  ffi.Int32 __ndigit,
  ffi.Pointer<ffi.Int32> __decpt,
  ffi.Pointer<ffi.Int32> __sign,
  ffi.Pointer<ffi.Int8> __buf,
  ffi.Uint64 __len,
);

typedef _dart_fcvt_r = int Function(
  double __value,
  int __ndigit,
  ffi.Pointer<ffi.Int32> __decpt,
  ffi.Pointer<ffi.Int32> __sign,
  ffi.Pointer<ffi.Int8> __buf,
  int __len,
);

typedef _c_mblen = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __s,
  ffi.Uint64 __n,
);

typedef _dart_mblen = int Function(
  ffi.Pointer<ffi.Int8> __s,
  int __n,
);

typedef _c_mbtowc = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> __pwc,
  ffi.Pointer<ffi.Int8> __s,
  ffi.Uint64 __n,
);

typedef _dart_mbtowc = int Function(
  ffi.Pointer<ffi.Int32> __pwc,
  ffi.Pointer<ffi.Int8> __s,
  int __n,
);

typedef _c_wctomb = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __s,
  ffi.Int32 __wchar,
);

typedef _dart_wctomb = int Function(
  ffi.Pointer<ffi.Int8> __s,
  int __wchar,
);

typedef _c_mbstowcs = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int32> __pwcs,
  ffi.Pointer<ffi.Int8> __s,
  ffi.Uint64 __n,
);

typedef _dart_mbstowcs = int Function(
  ffi.Pointer<ffi.Int32> __pwcs,
  ffi.Pointer<ffi.Int8> __s,
  int __n,
);

typedef _c_wcstombs = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int8> __s,
  ffi.Pointer<ffi.Int32> __pwcs,
  ffi.Uint64 __n,
);

typedef _dart_wcstombs = int Function(
  ffi.Pointer<ffi.Int8> __s,
  ffi.Pointer<ffi.Int32> __pwcs,
  int __n,
);

typedef _c_rpmatch = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __response,
);

typedef _dart_rpmatch = int Function(
  ffi.Pointer<ffi.Int8> __response,
);

typedef _c_getsubopt = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __optionp,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __tokens,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __valuep,
);

typedef _dart_getsubopt = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __optionp,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __tokens,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __valuep,
);

typedef _c_getloadavg = ffi.Int32 Function(
  ffi.Pointer<ffi.Double> __loadavg,
  ffi.Int32 __nelem,
);

typedef _dart_getloadavg = int Function(
  ffi.Pointer<ffi.Double> __loadavg,
  int __nelem,
);

typedef _c_decaf_bzero = ffi.Void Function(
  ffi.Pointer<ffi.Void> data,
  ffi.Uint64 size,
);

typedef _dart_decaf_bzero = void Function(
  ffi.Pointer<ffi.Void> data,
  int size,
);

typedef _c_decaf_memeq = ffi.Uint64 Function(
  ffi.Pointer<ffi.Void> data1,
  ffi.Pointer<ffi.Void> data2,
  ffi.Uint64 size,
);

typedef _dart_decaf_memeq = int Function(
  ffi.Pointer<ffi.Void> data1,
  ffi.Pointer<ffi.Void> data2,
  int size,
);

typedef _c_decaf_sha512_init = ffi.Void Function(
  ffi.Pointer<decaf_sha512_ctx_t> ctx,
);

typedef _dart_decaf_sha512_init = void Function(
  ffi.Pointer<decaf_sha512_ctx_t> ctx,
);

typedef _c_decaf_sha512_update = ffi.Void Function(
  ffi.Pointer<decaf_sha512_ctx_t> ctx,
  ffi.Pointer<ffi.Uint8> message,
  ffi.Uint64 message_len,
);

typedef _dart_decaf_sha512_update = void Function(
  ffi.Pointer<decaf_sha512_ctx_t> ctx,
  ffi.Pointer<ffi.Uint8> message,
  int message_len,
);

typedef _c_decaf_sha512_final = ffi.Void Function(
  ffi.Pointer<decaf_sha512_ctx_t> ctx,
  ffi.Pointer<ffi.Uint8> output,
  ffi.Uint64 output_len,
);

typedef _dart_decaf_sha512_final = void Function(
  ffi.Pointer<decaf_sha512_ctx_t> ctx,
  ffi.Pointer<ffi.Uint8> output,
  int output_len,
);

typedef _c_decaf_448_scalar_decode = ffi.Int32 Function(
  ffi.Pointer<decaf_448_scalar_t> out,
  ffi.Pointer<ffi.Uint8> ser,
);

typedef _dart_decaf_448_scalar_decode = int Function(
  ffi.Pointer<decaf_448_scalar_t> out,
  ffi.Pointer<ffi.Uint8> ser,
);

typedef _c_decaf_448_scalar_decode_long = ffi.Void Function(
  ffi.Pointer<decaf_448_scalar_t> out,
  ffi.Pointer<ffi.Uint8> ser,
  ffi.Uint64 ser_len,
);

typedef _dart_decaf_448_scalar_decode_long = void Function(
  ffi.Pointer<decaf_448_scalar_t> out,
  ffi.Pointer<ffi.Uint8> ser,
  int ser_len,
);

typedef _c_decaf_448_scalar_encode = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> ser,
  ffi.Pointer<decaf_448_scalar_t> s,
);

typedef _dart_decaf_448_scalar_encode = void Function(
  ffi.Pointer<ffi.Uint8> ser,
  ffi.Pointer<decaf_448_scalar_t> s,
);

typedef _c_decaf_448_scalar_add = ffi.Void Function(
  ffi.Pointer<decaf_448_scalar_t> out,
  ffi.Pointer<decaf_448_scalar_t> a,
  ffi.Pointer<decaf_448_scalar_t> b,
);

typedef _dart_decaf_448_scalar_add = void Function(
  ffi.Pointer<decaf_448_scalar_t> out,
  ffi.Pointer<decaf_448_scalar_t> a,
  ffi.Pointer<decaf_448_scalar_t> b,
);

typedef _c_decaf_448_scalar_eq = ffi.Uint64 Function(
  ffi.Pointer<decaf_448_scalar_t> a,
  ffi.Pointer<decaf_448_scalar_t> b,
);

typedef _dart_decaf_448_scalar_eq = int Function(
  ffi.Pointer<decaf_448_scalar_t> a,
  ffi.Pointer<decaf_448_scalar_t> b,
);

typedef _c_decaf_448_scalar_sub = ffi.Void Function(
  ffi.Pointer<decaf_448_scalar_t> out,
  ffi.Pointer<decaf_448_scalar_t> a,
  ffi.Pointer<decaf_448_scalar_t> b,
);

typedef _dart_decaf_448_scalar_sub = void Function(
  ffi.Pointer<decaf_448_scalar_t> out,
  ffi.Pointer<decaf_448_scalar_t> a,
  ffi.Pointer<decaf_448_scalar_t> b,
);

typedef _c_decaf_448_scalar_mul = ffi.Void Function(
  ffi.Pointer<decaf_448_scalar_t> out,
  ffi.Pointer<decaf_448_scalar_t> a,
  ffi.Pointer<decaf_448_scalar_t> b,
);

typedef _dart_decaf_448_scalar_mul = void Function(
  ffi.Pointer<decaf_448_scalar_t> out,
  ffi.Pointer<decaf_448_scalar_t> a,
  ffi.Pointer<decaf_448_scalar_t> b,
);

typedef _c_decaf_448_scalar_halve = ffi.Void Function(
  ffi.Pointer<decaf_448_scalar_t> out,
  ffi.Pointer<decaf_448_scalar_t> a,
);

typedef _dart_decaf_448_scalar_halve = void Function(
  ffi.Pointer<decaf_448_scalar_t> out,
  ffi.Pointer<decaf_448_scalar_t> a,
);

typedef _c_decaf_448_scalar_invert = ffi.Int32 Function(
  ffi.Pointer<decaf_448_scalar_t> out,
  ffi.Pointer<decaf_448_scalar_t> a,
);

typedef _dart_decaf_448_scalar_invert = int Function(
  ffi.Pointer<decaf_448_scalar_t> out,
  ffi.Pointer<decaf_448_scalar_t> a,
);

typedef _c_decaf_448_scalar_set_unsigned = ffi.Void Function(
  ffi.Pointer<decaf_448_scalar_t> out,
  ffi.Uint64 a,
);

typedef _dart_decaf_448_scalar_set_unsigned = void Function(
  ffi.Pointer<decaf_448_scalar_t> out,
  int a,
);

typedef _c_decaf_448_point_encode = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> ser,
  ffi.Pointer<decaf_448_point_t> pt,
);

typedef _dart_decaf_448_point_encode = void Function(
  ffi.Pointer<ffi.Uint8> ser,
  ffi.Pointer<decaf_448_point_t> pt,
);

typedef _c_decaf_448_point_decode = ffi.Int32 Function(
  ffi.Pointer<decaf_448_point_t> pt,
  ffi.Pointer<ffi.Uint8> ser,
  ffi.Uint64 allow_identity,
);

typedef _dart_decaf_448_point_decode = int Function(
  ffi.Pointer<decaf_448_point_t> pt,
  ffi.Pointer<ffi.Uint8> ser,
  int allow_identity,
);

typedef _c_decaf_448_point_eq = ffi.Uint64 Function(
  ffi.Pointer<decaf_448_point_t> a,
  ffi.Pointer<decaf_448_point_t> b,
);

typedef _dart_decaf_448_point_eq = int Function(
  ffi.Pointer<decaf_448_point_t> a,
  ffi.Pointer<decaf_448_point_t> b,
);

typedef _c_decaf_448_point_add = ffi.Void Function(
  ffi.Pointer<decaf_448_point_t> sum,
  ffi.Pointer<decaf_448_point_t> a,
  ffi.Pointer<decaf_448_point_t> b,
);

typedef _dart_decaf_448_point_add = void Function(
  ffi.Pointer<decaf_448_point_t> sum,
  ffi.Pointer<decaf_448_point_t> a,
  ffi.Pointer<decaf_448_point_t> b,
);

typedef _c_decaf_448_point_double = ffi.Void Function(
  ffi.Pointer<decaf_448_point_t> two_a,
  ffi.Pointer<decaf_448_point_t> a,
);

typedef _dart_decaf_448_point_double = void Function(
  ffi.Pointer<decaf_448_point_t> two_a,
  ffi.Pointer<decaf_448_point_t> a,
);

typedef _c_decaf_448_point_sub = ffi.Void Function(
  ffi.Pointer<decaf_448_point_t> diff,
  ffi.Pointer<decaf_448_point_t> a,
  ffi.Pointer<decaf_448_point_t> b,
);

typedef _dart_decaf_448_point_sub = void Function(
  ffi.Pointer<decaf_448_point_t> diff,
  ffi.Pointer<decaf_448_point_t> a,
  ffi.Pointer<decaf_448_point_t> b,
);

typedef _c_decaf_448_point_negate = ffi.Void Function(
  ffi.Pointer<decaf_448_point_t> nega,
  ffi.Pointer<decaf_448_point_t> a,
);

typedef _dart_decaf_448_point_negate = void Function(
  ffi.Pointer<decaf_448_point_t> nega,
  ffi.Pointer<decaf_448_point_t> a,
);

typedef _c_decaf_448_point_scalarmul = ffi.Void Function(
  ffi.Pointer<decaf_448_point_t> scaled,
  ffi.Pointer<decaf_448_point_t> base,
  ffi.Pointer<decaf_448_scalar_t> scalar,
);

typedef _dart_decaf_448_point_scalarmul = void Function(
  ffi.Pointer<decaf_448_point_t> scaled,
  ffi.Pointer<decaf_448_point_t> base,
  ffi.Pointer<decaf_448_scalar_t> scalar,
);

typedef _c_decaf_448_direct_scalarmul = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> scaled,
  ffi.Pointer<ffi.Uint8> base,
  ffi.Pointer<decaf_448_scalar_t> scalar,
  ffi.Uint64 allow_identity,
  ffi.Uint64 short_circuit,
);

typedef _dart_decaf_448_direct_scalarmul = int Function(
  ffi.Pointer<ffi.Uint8> scaled,
  ffi.Pointer<ffi.Uint8> base,
  ffi.Pointer<decaf_448_scalar_t> scalar,
  int allow_identity,
  int short_circuit,
);

typedef _c_decaf_x448 = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> shared,
  ffi.Pointer<ffi.Uint8> base,
  ffi.Pointer<ffi.Uint8> scalar,
);

typedef _dart_decaf_x448 = int Function(
  ffi.Pointer<ffi.Uint8> shared,
  ffi.Pointer<ffi.Uint8> base,
  ffi.Pointer<ffi.Uint8> scalar,
);

typedef _c_decaf_448_point_mul_by_ratio_and_encode_like_x448 = ffi.Void
    Function(
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<decaf_448_point_t> p,
);

typedef _dart_decaf_448_point_mul_by_ratio_and_encode_like_x448 = void Function(
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<decaf_448_point_t> p,
);

typedef _c_decaf_x448_generate_key = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.Uint8> scalar,
);

typedef _dart_decaf_x448_generate_key = void Function(
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.Uint8> scalar,
);

typedef _c_decaf_x448_derive_public_key = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.Uint8> scalar,
);

typedef _dart_decaf_x448_derive_public_key = void Function(
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.Uint8> scalar,
);

typedef _c_decaf_448_precompute = ffi.Void Function(
  ffi.Pointer<decaf_448_precomputed_s> a,
  ffi.Pointer<decaf_448_point_t> b,
);

typedef _dart_decaf_448_precompute = void Function(
  ffi.Pointer<decaf_448_precomputed_s> a,
  ffi.Pointer<decaf_448_point_t> b,
);

typedef _c_decaf_448_precomputed_scalarmul = ffi.Void Function(
  ffi.Pointer<decaf_448_point_t> scaled,
  ffi.Pointer<decaf_448_precomputed_s> base,
  ffi.Pointer<decaf_448_scalar_t> scalar,
);

typedef _dart_decaf_448_precomputed_scalarmul = void Function(
  ffi.Pointer<decaf_448_point_t> scaled,
  ffi.Pointer<decaf_448_precomputed_s> base,
  ffi.Pointer<decaf_448_scalar_t> scalar,
);

typedef _c_decaf_448_point_double_scalarmul = ffi.Void Function(
  ffi.Pointer<decaf_448_point_t> combo,
  ffi.Pointer<decaf_448_point_t> base1,
  ffi.Pointer<decaf_448_scalar_t> scalar1,
  ffi.Pointer<decaf_448_point_t> base2,
  ffi.Pointer<decaf_448_scalar_t> scalar2,
);

typedef _dart_decaf_448_point_double_scalarmul = void Function(
  ffi.Pointer<decaf_448_point_t> combo,
  ffi.Pointer<decaf_448_point_t> base1,
  ffi.Pointer<decaf_448_scalar_t> scalar1,
  ffi.Pointer<decaf_448_point_t> base2,
  ffi.Pointer<decaf_448_scalar_t> scalar2,
);

typedef _c_decaf_448_point_dual_scalarmul = ffi.Void Function(
  ffi.Pointer<decaf_448_point_t> a1,
  ffi.Pointer<decaf_448_point_t> a2,
  ffi.Pointer<decaf_448_point_t> base1,
  ffi.Pointer<decaf_448_scalar_t> scalar1,
  ffi.Pointer<decaf_448_scalar_t> scalar2,
);

typedef _dart_decaf_448_point_dual_scalarmul = void Function(
  ffi.Pointer<decaf_448_point_t> a1,
  ffi.Pointer<decaf_448_point_t> a2,
  ffi.Pointer<decaf_448_point_t> base1,
  ffi.Pointer<decaf_448_scalar_t> scalar1,
  ffi.Pointer<decaf_448_scalar_t> scalar2,
);

typedef _c_decaf_448_base_double_scalarmul_non_secret = ffi.Void Function(
  ffi.Pointer<decaf_448_point_t> combo,
  ffi.Pointer<decaf_448_scalar_t> scalar1,
  ffi.Pointer<decaf_448_point_t> base2,
  ffi.Pointer<decaf_448_scalar_t> scalar2,
);

typedef _dart_decaf_448_base_double_scalarmul_non_secret = void Function(
  ffi.Pointer<decaf_448_point_t> combo,
  ffi.Pointer<decaf_448_scalar_t> scalar1,
  ffi.Pointer<decaf_448_point_t> base2,
  ffi.Pointer<decaf_448_scalar_t> scalar2,
);

typedef _c_decaf_448_point_cond_sel = ffi.Void Function(
  ffi.Pointer<decaf_448_point_t> out,
  ffi.Pointer<decaf_448_point_t> a,
  ffi.Pointer<decaf_448_point_t> b,
  ffi.Uint64 pick_b,
);

typedef _dart_decaf_448_point_cond_sel = void Function(
  ffi.Pointer<decaf_448_point_t> out,
  ffi.Pointer<decaf_448_point_t> a,
  ffi.Pointer<decaf_448_point_t> b,
  int pick_b,
);

typedef _c_decaf_448_scalar_cond_sel = ffi.Void Function(
  ffi.Pointer<decaf_448_scalar_t> out,
  ffi.Pointer<decaf_448_scalar_t> a,
  ffi.Pointer<decaf_448_scalar_t> b,
  ffi.Uint64 pick_b,
);

typedef _dart_decaf_448_scalar_cond_sel = void Function(
  ffi.Pointer<decaf_448_scalar_t> out,
  ffi.Pointer<decaf_448_scalar_t> a,
  ffi.Pointer<decaf_448_scalar_t> b,
  int pick_b,
);

typedef _c_decaf_448_point_valid = ffi.Uint64 Function(
  ffi.Pointer<decaf_448_point_t> to_test,
);

typedef _dart_decaf_448_point_valid = int Function(
  ffi.Pointer<decaf_448_point_t> to_test,
);

typedef _c_decaf_448_point_debugging_torque = ffi.Void Function(
  ffi.Pointer<decaf_448_point_t> q,
  ffi.Pointer<decaf_448_point_t> p,
);

typedef _dart_decaf_448_point_debugging_torque = void Function(
  ffi.Pointer<decaf_448_point_t> q,
  ffi.Pointer<decaf_448_point_t> p,
);

typedef _c_decaf_448_point_debugging_pscale = ffi.Void Function(
  ffi.Pointer<decaf_448_point_t> q,
  ffi.Pointer<decaf_448_point_t> p,
  ffi.Pointer<ffi.Uint8> factor,
);

typedef _dart_decaf_448_point_debugging_pscale = void Function(
  ffi.Pointer<decaf_448_point_t> q,
  ffi.Pointer<decaf_448_point_t> p,
  ffi.Pointer<ffi.Uint8> factor,
);

typedef _c_decaf_448_point_from_hash_nonuniform = ffi.Void Function(
  ffi.Pointer<decaf_448_point_t> pt,
  ffi.Pointer<ffi.Uint8> hashed_data,
);

typedef _dart_decaf_448_point_from_hash_nonuniform = void Function(
  ffi.Pointer<decaf_448_point_t> pt,
  ffi.Pointer<ffi.Uint8> hashed_data,
);

typedef _c_decaf_448_point_from_hash_uniform = ffi.Void Function(
  ffi.Pointer<decaf_448_point_t> pt,
  ffi.Pointer<ffi.Uint8> hashed_data,
);

typedef _dart_decaf_448_point_from_hash_uniform = void Function(
  ffi.Pointer<decaf_448_point_t> pt,
  ffi.Pointer<ffi.Uint8> hashed_data,
);

typedef _c_decaf_448_invert_elligator_nonuniform = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> recovered_hash,
  ffi.Pointer<decaf_448_point_t> pt,
  ffi.Uint32 which,
);

typedef _dart_decaf_448_invert_elligator_nonuniform = int Function(
  ffi.Pointer<ffi.Uint8> recovered_hash,
  ffi.Pointer<decaf_448_point_t> pt,
  int which,
);

typedef _c_decaf_448_invert_elligator_uniform = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> recovered_hash,
  ffi.Pointer<decaf_448_point_t> pt,
  ffi.Uint32 which,
);

typedef _dart_decaf_448_invert_elligator_uniform = int Function(
  ffi.Pointer<ffi.Uint8> recovered_hash,
  ffi.Pointer<decaf_448_point_t> pt,
  int which,
);

typedef _c_decaf_448_scalar_destroy = ffi.Void Function(
  ffi.Pointer<decaf_448_scalar_t> scalar,
);

typedef _dart_decaf_448_scalar_destroy = void Function(
  ffi.Pointer<decaf_448_scalar_t> scalar,
);

typedef _c_decaf_448_point_destroy = ffi.Void Function(
  ffi.Pointer<decaf_448_point_t> point,
);

typedef _dart_decaf_448_point_destroy = void Function(
  ffi.Pointer<decaf_448_point_t> point,
);

typedef _c_decaf_448_precomputed_destroy = ffi.Void Function(
  ffi.Pointer<decaf_448_precomputed_s> pre,
);

typedef _dart_decaf_448_precomputed_destroy = void Function(
  ffi.Pointer<decaf_448_precomputed_s> pre,
);

typedef _c_decaf_255_scalar_decode = ffi.Int32 Function(
  ffi.Pointer<decaf_255_scalar_t> out,
  ffi.Pointer<ffi.Uint8> ser,
);

typedef _dart_decaf_255_scalar_decode = int Function(
  ffi.Pointer<decaf_255_scalar_t> out,
  ffi.Pointer<ffi.Uint8> ser,
);

typedef _c_decaf_255_scalar_decode_long = ffi.Void Function(
  ffi.Pointer<decaf_255_scalar_t> out,
  ffi.Pointer<ffi.Uint8> ser,
  ffi.Uint64 ser_len,
);

typedef _dart_decaf_255_scalar_decode_long = void Function(
  ffi.Pointer<decaf_255_scalar_t> out,
  ffi.Pointer<ffi.Uint8> ser,
  int ser_len,
);

typedef _c_decaf_255_scalar_encode = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> ser,
  ffi.Pointer<decaf_255_scalar_t> s,
);

typedef _dart_decaf_255_scalar_encode = void Function(
  ffi.Pointer<ffi.Uint8> ser,
  ffi.Pointer<decaf_255_scalar_t> s,
);

typedef _c_decaf_255_scalar_add = ffi.Void Function(
  ffi.Pointer<decaf_255_scalar_t> out,
  ffi.Pointer<decaf_255_scalar_t> a,
  ffi.Pointer<decaf_255_scalar_t> b,
);

typedef _dart_decaf_255_scalar_add = void Function(
  ffi.Pointer<decaf_255_scalar_t> out,
  ffi.Pointer<decaf_255_scalar_t> a,
  ffi.Pointer<decaf_255_scalar_t> b,
);

typedef _c_decaf_255_scalar_eq = ffi.Uint64 Function(
  ffi.Pointer<decaf_255_scalar_t> a,
  ffi.Pointer<decaf_255_scalar_t> b,
);

typedef _dart_decaf_255_scalar_eq = int Function(
  ffi.Pointer<decaf_255_scalar_t> a,
  ffi.Pointer<decaf_255_scalar_t> b,
);

typedef _c_decaf_255_scalar_sub = ffi.Void Function(
  ffi.Pointer<decaf_255_scalar_t> out,
  ffi.Pointer<decaf_255_scalar_t> a,
  ffi.Pointer<decaf_255_scalar_t> b,
);

typedef _dart_decaf_255_scalar_sub = void Function(
  ffi.Pointer<decaf_255_scalar_t> out,
  ffi.Pointer<decaf_255_scalar_t> a,
  ffi.Pointer<decaf_255_scalar_t> b,
);

typedef _c_decaf_255_scalar_mul = ffi.Void Function(
  ffi.Pointer<decaf_255_scalar_t> out,
  ffi.Pointer<decaf_255_scalar_t> a,
  ffi.Pointer<decaf_255_scalar_t> b,
);

typedef _dart_decaf_255_scalar_mul = void Function(
  ffi.Pointer<decaf_255_scalar_t> out,
  ffi.Pointer<decaf_255_scalar_t> a,
  ffi.Pointer<decaf_255_scalar_t> b,
);

typedef _c_decaf_255_scalar_halve = ffi.Void Function(
  ffi.Pointer<decaf_255_scalar_t> out,
  ffi.Pointer<decaf_255_scalar_t> a,
);

typedef _dart_decaf_255_scalar_halve = void Function(
  ffi.Pointer<decaf_255_scalar_t> out,
  ffi.Pointer<decaf_255_scalar_t> a,
);

typedef _c_decaf_255_scalar_invert = ffi.Int32 Function(
  ffi.Pointer<decaf_255_scalar_t> out,
  ffi.Pointer<decaf_255_scalar_t> a,
);

typedef _dart_decaf_255_scalar_invert = int Function(
  ffi.Pointer<decaf_255_scalar_t> out,
  ffi.Pointer<decaf_255_scalar_t> a,
);

typedef _c_decaf_255_scalar_set_unsigned = ffi.Void Function(
  ffi.Pointer<decaf_255_scalar_t> out,
  ffi.Uint64 a,
);

typedef _dart_decaf_255_scalar_set_unsigned = void Function(
  ffi.Pointer<decaf_255_scalar_t> out,
  int a,
);

typedef _c_decaf_255_point_encode = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> ser,
  ffi.Pointer<decaf_255_point_t> pt,
);

typedef _dart_decaf_255_point_encode = void Function(
  ffi.Pointer<ffi.Uint8> ser,
  ffi.Pointer<decaf_255_point_t> pt,
);

typedef _c_decaf_255_point_decode = ffi.Int32 Function(
  ffi.Pointer<decaf_255_point_t> pt,
  ffi.Pointer<ffi.Uint8> ser,
  ffi.Uint64 allow_identity,
);

typedef _dart_decaf_255_point_decode = int Function(
  ffi.Pointer<decaf_255_point_t> pt,
  ffi.Pointer<ffi.Uint8> ser,
  int allow_identity,
);

typedef _c_decaf_255_point_eq = ffi.Uint64 Function(
  ffi.Pointer<decaf_255_point_t> a,
  ffi.Pointer<decaf_255_point_t> b,
);

typedef _dart_decaf_255_point_eq = int Function(
  ffi.Pointer<decaf_255_point_t> a,
  ffi.Pointer<decaf_255_point_t> b,
);

typedef _c_decaf_255_point_add = ffi.Void Function(
  ffi.Pointer<decaf_255_point_t> sum,
  ffi.Pointer<decaf_255_point_t> a,
  ffi.Pointer<decaf_255_point_t> b,
);

typedef _dart_decaf_255_point_add = void Function(
  ffi.Pointer<decaf_255_point_t> sum,
  ffi.Pointer<decaf_255_point_t> a,
  ffi.Pointer<decaf_255_point_t> b,
);

typedef _c_decaf_255_point_double = ffi.Void Function(
  ffi.Pointer<decaf_255_point_t> two_a,
  ffi.Pointer<decaf_255_point_t> a,
);

typedef _dart_decaf_255_point_double = void Function(
  ffi.Pointer<decaf_255_point_t> two_a,
  ffi.Pointer<decaf_255_point_t> a,
);

typedef _c_decaf_255_point_sub = ffi.Void Function(
  ffi.Pointer<decaf_255_point_t> diff,
  ffi.Pointer<decaf_255_point_t> a,
  ffi.Pointer<decaf_255_point_t> b,
);

typedef _dart_decaf_255_point_sub = void Function(
  ffi.Pointer<decaf_255_point_t> diff,
  ffi.Pointer<decaf_255_point_t> a,
  ffi.Pointer<decaf_255_point_t> b,
);

typedef _c_decaf_255_point_negate = ffi.Void Function(
  ffi.Pointer<decaf_255_point_t> nega,
  ffi.Pointer<decaf_255_point_t> a,
);

typedef _dart_decaf_255_point_negate = void Function(
  ffi.Pointer<decaf_255_point_t> nega,
  ffi.Pointer<decaf_255_point_t> a,
);

typedef _c_decaf_255_point_scalarmul = ffi.Void Function(
  ffi.Pointer<decaf_255_point_t> scaled,
  ffi.Pointer<decaf_255_point_t> base,
  ffi.Pointer<decaf_255_scalar_t> scalar,
);

typedef _dart_decaf_255_point_scalarmul = void Function(
  ffi.Pointer<decaf_255_point_t> scaled,
  ffi.Pointer<decaf_255_point_t> base,
  ffi.Pointer<decaf_255_scalar_t> scalar,
);

typedef _c_decaf_255_direct_scalarmul = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> scaled,
  ffi.Pointer<ffi.Uint8> base,
  ffi.Pointer<decaf_255_scalar_t> scalar,
  ffi.Uint64 allow_identity,
  ffi.Uint64 short_circuit,
);

typedef _dart_decaf_255_direct_scalarmul = int Function(
  ffi.Pointer<ffi.Uint8> scaled,
  ffi.Pointer<ffi.Uint8> base,
  ffi.Pointer<decaf_255_scalar_t> scalar,
  int allow_identity,
  int short_circuit,
);

typedef _c_decaf_x25519 = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> shared,
  ffi.Pointer<ffi.Uint8> base,
  ffi.Pointer<ffi.Uint8> scalar,
);

typedef _dart_decaf_x25519 = int Function(
  ffi.Pointer<ffi.Uint8> shared,
  ffi.Pointer<ffi.Uint8> base,
  ffi.Pointer<ffi.Uint8> scalar,
);

typedef _c_decaf_255_point_mul_by_ratio_and_encode_like_x25519 = ffi.Void
    Function(
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<decaf_255_point_t> p,
);

typedef _dart_decaf_255_point_mul_by_ratio_and_encode_like_x25519 = void
    Function(
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<decaf_255_point_t> p,
);

typedef _c_decaf_x25519_generate_key = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.Uint8> scalar,
);

typedef _dart_decaf_x25519_generate_key = void Function(
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.Uint8> scalar,
);

typedef _c_decaf_x25519_derive_public_key = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.Uint8> scalar,
);

typedef _dart_decaf_x25519_derive_public_key = void Function(
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.Uint8> scalar,
);

typedef _c_decaf_255_precompute = ffi.Void Function(
  ffi.Pointer<decaf_255_precomputed_s> a,
  ffi.Pointer<decaf_255_point_t> b,
);

typedef _dart_decaf_255_precompute = void Function(
  ffi.Pointer<decaf_255_precomputed_s> a,
  ffi.Pointer<decaf_255_point_t> b,
);

typedef _c_decaf_255_precomputed_scalarmul = ffi.Void Function(
  ffi.Pointer<decaf_255_point_t> scaled,
  ffi.Pointer<decaf_255_precomputed_s> base,
  ffi.Pointer<decaf_255_scalar_t> scalar,
);

typedef _dart_decaf_255_precomputed_scalarmul = void Function(
  ffi.Pointer<decaf_255_point_t> scaled,
  ffi.Pointer<decaf_255_precomputed_s> base,
  ffi.Pointer<decaf_255_scalar_t> scalar,
);

typedef _c_decaf_255_point_double_scalarmul = ffi.Void Function(
  ffi.Pointer<decaf_255_point_t> combo,
  ffi.Pointer<decaf_255_point_t> base1,
  ffi.Pointer<decaf_255_scalar_t> scalar1,
  ffi.Pointer<decaf_255_point_t> base2,
  ffi.Pointer<decaf_255_scalar_t> scalar2,
);

typedef _dart_decaf_255_point_double_scalarmul = void Function(
  ffi.Pointer<decaf_255_point_t> combo,
  ffi.Pointer<decaf_255_point_t> base1,
  ffi.Pointer<decaf_255_scalar_t> scalar1,
  ffi.Pointer<decaf_255_point_t> base2,
  ffi.Pointer<decaf_255_scalar_t> scalar2,
);

typedef _c_decaf_255_point_dual_scalarmul = ffi.Void Function(
  ffi.Pointer<decaf_255_point_t> a1,
  ffi.Pointer<decaf_255_point_t> a2,
  ffi.Pointer<decaf_255_point_t> base1,
  ffi.Pointer<decaf_255_scalar_t> scalar1,
  ffi.Pointer<decaf_255_scalar_t> scalar2,
);

typedef _dart_decaf_255_point_dual_scalarmul = void Function(
  ffi.Pointer<decaf_255_point_t> a1,
  ffi.Pointer<decaf_255_point_t> a2,
  ffi.Pointer<decaf_255_point_t> base1,
  ffi.Pointer<decaf_255_scalar_t> scalar1,
  ffi.Pointer<decaf_255_scalar_t> scalar2,
);

typedef _c_decaf_255_base_double_scalarmul_non_secret = ffi.Void Function(
  ffi.Pointer<decaf_255_point_t> combo,
  ffi.Pointer<decaf_255_scalar_t> scalar1,
  ffi.Pointer<decaf_255_point_t> base2,
  ffi.Pointer<decaf_255_scalar_t> scalar2,
);

typedef _dart_decaf_255_base_double_scalarmul_non_secret = void Function(
  ffi.Pointer<decaf_255_point_t> combo,
  ffi.Pointer<decaf_255_scalar_t> scalar1,
  ffi.Pointer<decaf_255_point_t> base2,
  ffi.Pointer<decaf_255_scalar_t> scalar2,
);

typedef _c_decaf_255_point_cond_sel = ffi.Void Function(
  ffi.Pointer<decaf_255_point_t> out,
  ffi.Pointer<decaf_255_point_t> a,
  ffi.Pointer<decaf_255_point_t> b,
  ffi.Uint64 pick_b,
);

typedef _dart_decaf_255_point_cond_sel = void Function(
  ffi.Pointer<decaf_255_point_t> out,
  ffi.Pointer<decaf_255_point_t> a,
  ffi.Pointer<decaf_255_point_t> b,
  int pick_b,
);

typedef _c_decaf_255_scalar_cond_sel = ffi.Void Function(
  ffi.Pointer<decaf_255_scalar_t> out,
  ffi.Pointer<decaf_255_scalar_t> a,
  ffi.Pointer<decaf_255_scalar_t> b,
  ffi.Uint64 pick_b,
);

typedef _dart_decaf_255_scalar_cond_sel = void Function(
  ffi.Pointer<decaf_255_scalar_t> out,
  ffi.Pointer<decaf_255_scalar_t> a,
  ffi.Pointer<decaf_255_scalar_t> b,
  int pick_b,
);

typedef _c_decaf_255_point_valid = ffi.Uint64 Function(
  ffi.Pointer<decaf_255_point_t> to_test,
);

typedef _dart_decaf_255_point_valid = int Function(
  ffi.Pointer<decaf_255_point_t> to_test,
);

typedef _c_decaf_255_point_debugging_torque = ffi.Void Function(
  ffi.Pointer<decaf_255_point_t> q,
  ffi.Pointer<decaf_255_point_t> p,
);

typedef _dart_decaf_255_point_debugging_torque = void Function(
  ffi.Pointer<decaf_255_point_t> q,
  ffi.Pointer<decaf_255_point_t> p,
);

typedef _c_decaf_255_point_debugging_pscale = ffi.Void Function(
  ffi.Pointer<decaf_255_point_t> q,
  ffi.Pointer<decaf_255_point_t> p,
  ffi.Pointer<ffi.Uint8> factor,
);

typedef _dart_decaf_255_point_debugging_pscale = void Function(
  ffi.Pointer<decaf_255_point_t> q,
  ffi.Pointer<decaf_255_point_t> p,
  ffi.Pointer<ffi.Uint8> factor,
);

typedef _c_decaf_255_point_from_hash_nonuniform = ffi.Void Function(
  ffi.Pointer<decaf_255_point_t> pt,
  ffi.Pointer<ffi.Uint8> hashed_data,
);

typedef _dart_decaf_255_point_from_hash_nonuniform = void Function(
  ffi.Pointer<decaf_255_point_t> pt,
  ffi.Pointer<ffi.Uint8> hashed_data,
);

typedef _c_decaf_255_point_from_hash_uniform = ffi.Void Function(
  ffi.Pointer<decaf_255_point_t> pt,
  ffi.Pointer<ffi.Uint8> hashed_data,
);

typedef _dart_decaf_255_point_from_hash_uniform = void Function(
  ffi.Pointer<decaf_255_point_t> pt,
  ffi.Pointer<ffi.Uint8> hashed_data,
);

typedef _c_decaf_255_invert_elligator_nonuniform = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> recovered_hash,
  ffi.Pointer<decaf_255_point_t> pt,
  ffi.Uint32 which,
);

typedef _dart_decaf_255_invert_elligator_nonuniform = int Function(
  ffi.Pointer<ffi.Uint8> recovered_hash,
  ffi.Pointer<decaf_255_point_t> pt,
  int which,
);

typedef _c_decaf_255_invert_elligator_uniform = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> recovered_hash,
  ffi.Pointer<decaf_255_point_t> pt,
  ffi.Uint32 which,
);

typedef _dart_decaf_255_invert_elligator_uniform = int Function(
  ffi.Pointer<ffi.Uint8> recovered_hash,
  ffi.Pointer<decaf_255_point_t> pt,
  int which,
);

typedef _c_decaf_255_scalar_destroy = ffi.Void Function(
  ffi.Pointer<decaf_255_scalar_t> scalar,
);

typedef _dart_decaf_255_scalar_destroy = void Function(
  ffi.Pointer<decaf_255_scalar_t> scalar,
);

typedef _c_decaf_255_point_destroy = ffi.Void Function(
  ffi.Pointer<decaf_255_point_t> point,
);

typedef _dart_decaf_255_point_destroy = void Function(
  ffi.Pointer<decaf_255_point_t> point,
);

typedef _c_decaf_255_precomputed_destroy = ffi.Void Function(
  ffi.Pointer<decaf_255_precomputed_s> pre,
);

typedef _dart_decaf_255_precomputed_destroy = void Function(
  ffi.Pointer<decaf_255_precomputed_s> pre,
);

typedef _c_decaf_sha3_init = ffi.Void Function(
  ffi.Pointer<decaf_keccak_sponge_s> sponge,
  ffi.Pointer<decaf_kparams_s> params,
);

typedef _dart_decaf_sha3_init = void Function(
  ffi.Pointer<decaf_keccak_sponge_s> sponge,
  ffi.Pointer<decaf_kparams_s> params,
);

typedef _c_decaf_sha3_update = ffi.Int32 Function(
  ffi.Pointer<decaf_keccak_sponge_s> sponge,
  ffi.Pointer<ffi.Uint8> in_1,
  ffi.Uint64 len,
);

typedef _dart_decaf_sha3_update = int Function(
  ffi.Pointer<decaf_keccak_sponge_s> sponge,
  ffi.Pointer<ffi.Uint8> in_1,
  int len,
);

typedef _c_decaf_sha3_output = ffi.Int32 Function(
  ffi.Pointer<decaf_keccak_sponge_s> sponge,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Uint64 len,
);

typedef _dart_decaf_sha3_output = int Function(
  ffi.Pointer<decaf_keccak_sponge_s> sponge,
  ffi.Pointer<ffi.Uint8> out,
  int len,
);

typedef _c_decaf_sha3_final = ffi.Int32 Function(
  ffi.Pointer<decaf_keccak_sponge_s> sponge,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Uint64 len,
);

typedef _dart_decaf_sha3_final = int Function(
  ffi.Pointer<decaf_keccak_sponge_s> sponge,
  ffi.Pointer<ffi.Uint8> out,
  int len,
);

typedef _c_decaf_sha3_reset = ffi.Void Function(
  ffi.Pointer<decaf_keccak_sponge_s> sponge,
);

typedef _dart_decaf_sha3_reset = void Function(
  ffi.Pointer<decaf_keccak_sponge_s> sponge,
);

typedef _c_decaf_sha3_default_output_bytes = ffi.Uint64 Function(
  ffi.Pointer<decaf_keccak_sponge_s> sponge,
);

typedef _dart_decaf_sha3_default_output_bytes = int Function(
  ffi.Pointer<decaf_keccak_sponge_s> sponge,
);

typedef _c_decaf_sha3_max_output_bytes = ffi.Uint64 Function(
  ffi.Pointer<decaf_keccak_sponge_s> sponge,
);

typedef _dart_decaf_sha3_max_output_bytes = int Function(
  ffi.Pointer<decaf_keccak_sponge_s> sponge,
);

typedef _c_decaf_sha3_destroy = ffi.Void Function(
  ffi.Pointer<decaf_keccak_sponge_s> sponge,
);

typedef _dart_decaf_sha3_destroy = void Function(
  ffi.Pointer<decaf_keccak_sponge_s> sponge,
);

typedef _c_decaf_sha3_hash = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> out,
  ffi.Uint64 outlen,
  ffi.Pointer<ffi.Uint8> in_1,
  ffi.Uint64 inlen,
  ffi.Pointer<decaf_kparams_s> params,
);

typedef _dart_decaf_sha3_hash = int Function(
  ffi.Pointer<ffi.Uint8> out,
  int outlen,
  ffi.Pointer<ffi.Uint8> in_1,
  int inlen,
  ffi.Pointer<decaf_kparams_s> params,
);

typedef _c_decaf_spongerng_init_from_buffer = ffi.Void Function(
  ffi.Pointer<decaf_keccak_prng_s> prng,
  ffi.Pointer<ffi.Uint8> in_1,
  ffi.Uint64 len,
  ffi.Int32 deterministic,
);

typedef _dart_decaf_spongerng_init_from_buffer = void Function(
  ffi.Pointer<decaf_keccak_prng_s> prng,
  ffi.Pointer<ffi.Uint8> in_1,
  int len,
  int deterministic,
);

typedef _c_decaf_spongerng_init_from_file = ffi.Int32 Function(
  ffi.Pointer<decaf_keccak_prng_s> prng,
  ffi.Pointer<ffi.Int8> file,
  ffi.Uint64 len,
  ffi.Int32 deterministic,
);

typedef _dart_decaf_spongerng_init_from_file = int Function(
  ffi.Pointer<decaf_keccak_prng_s> prng,
  ffi.Pointer<ffi.Int8> file,
  int len,
  int deterministic,
);

typedef _c_decaf_spongerng_init_from_dev_urandom = ffi.Int32 Function(
  ffi.Pointer<decaf_keccak_prng_s> prng,
);

typedef _dart_decaf_spongerng_init_from_dev_urandom = int Function(
  ffi.Pointer<decaf_keccak_prng_s> prng,
);

typedef _c_decaf_spongerng_next = ffi.Void Function(
  ffi.Pointer<decaf_keccak_prng_s> prng,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Uint64 len,
);

typedef _dart_decaf_spongerng_next = void Function(
  ffi.Pointer<decaf_keccak_prng_s> prng,
  ffi.Pointer<ffi.Uint8> out,
  int len,
);

typedef _c_decaf_spongerng_stir = ffi.Void Function(
  ffi.Pointer<decaf_keccak_prng_s> prng,
  ffi.Pointer<ffi.Uint8> in_1,
  ffi.Uint64 len,
);

typedef _dart_decaf_spongerng_stir = void Function(
  ffi.Pointer<decaf_keccak_prng_s> prng,
  ffi.Pointer<ffi.Uint8> in_1,
  int len,
);

typedef _c_decaf_ed448_derive_public_key = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> pubkey,
  ffi.Pointer<ffi.Uint8> privkey,
);

typedef _dart_decaf_ed448_derive_public_key = void Function(
  ffi.Pointer<ffi.Uint8> pubkey,
  ffi.Pointer<ffi.Uint8> privkey,
);

typedef _c_decaf_ed448_sign = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> signature,
  ffi.Pointer<ffi.Uint8> privkey,
  ffi.Pointer<ffi.Uint8> pubkey,
  ffi.Pointer<ffi.Uint8> message,
  ffi.Uint64 message_len,
  ffi.Uint8 prehashed,
  ffi.Pointer<ffi.Uint8> context,
  ffi.Uint8 context_len,
);

typedef _dart_decaf_ed448_sign = void Function(
  ffi.Pointer<ffi.Uint8> signature,
  ffi.Pointer<ffi.Uint8> privkey,
  ffi.Pointer<ffi.Uint8> pubkey,
  ffi.Pointer<ffi.Uint8> message,
  int message_len,
  int prehashed,
  ffi.Pointer<ffi.Uint8> context,
  int context_len,
);

typedef _c_decaf_ed448_sign_prehash = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> signature,
  ffi.Pointer<ffi.Uint8> privkey,
  ffi.Pointer<ffi.Uint8> pubkey,
  ffi.Pointer<decaf_shake256_ctx_t> hash,
  ffi.Pointer<ffi.Uint8> context,
  ffi.Uint8 context_len,
);

typedef _dart_decaf_ed448_sign_prehash = void Function(
  ffi.Pointer<ffi.Uint8> signature,
  ffi.Pointer<ffi.Uint8> privkey,
  ffi.Pointer<ffi.Uint8> pubkey,
  ffi.Pointer<decaf_shake256_ctx_t> hash,
  ffi.Pointer<ffi.Uint8> context,
  int context_len,
);

typedef _c_decaf_ed448_prehash_init = ffi.Void Function(
  ffi.Pointer<decaf_shake256_ctx_t> hash,
);

typedef _dart_decaf_ed448_prehash_init = void Function(
  ffi.Pointer<decaf_shake256_ctx_t> hash,
);

typedef _c_decaf_ed448_verify = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> signature,
  ffi.Pointer<ffi.Uint8> pubkey,
  ffi.Pointer<ffi.Uint8> message,
  ffi.Uint64 message_len,
  ffi.Uint8 prehashed,
  ffi.Pointer<ffi.Uint8> context,
  ffi.Uint8 context_len,
);

typedef _dart_decaf_ed448_verify = int Function(
  ffi.Pointer<ffi.Uint8> signature,
  ffi.Pointer<ffi.Uint8> pubkey,
  ffi.Pointer<ffi.Uint8> message,
  int message_len,
  int prehashed,
  ffi.Pointer<ffi.Uint8> context,
  int context_len,
);

typedef _c_decaf_ed448_verify_prehash = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> signature,
  ffi.Pointer<ffi.Uint8> pubkey,
  ffi.Pointer<decaf_shake256_ctx_t> hash,
  ffi.Pointer<ffi.Uint8> context,
  ffi.Uint8 context_len,
);

typedef _dart_decaf_ed448_verify_prehash = int Function(
  ffi.Pointer<ffi.Uint8> signature,
  ffi.Pointer<ffi.Uint8> pubkey,
  ffi.Pointer<decaf_shake256_ctx_t> hash,
  ffi.Pointer<ffi.Uint8> context,
  int context_len,
);

typedef _c_decaf_448_point_mul_by_ratio_and_encode_like_eddsa = ffi.Void
    Function(
  ffi.Pointer<ffi.Uint8> enc,
  ffi.Pointer<decaf_448_point_t> p,
);

typedef _dart_decaf_448_point_mul_by_ratio_and_encode_like_eddsa = void
    Function(
  ffi.Pointer<ffi.Uint8> enc,
  ffi.Pointer<decaf_448_point_t> p,
);

typedef _c_decaf_448_point_decode_like_eddsa_and_mul_by_ratio = ffi.Int32
    Function(
  ffi.Pointer<decaf_448_point_t> p,
  ffi.Pointer<ffi.Uint8> enc,
);

typedef _dart_decaf_448_point_decode_like_eddsa_and_mul_by_ratio = int Function(
  ffi.Pointer<decaf_448_point_t> p,
  ffi.Pointer<ffi.Uint8> enc,
);

typedef _c_decaf_ed448_convert_public_key_to_x448 = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> x,
  ffi.Pointer<ffi.Uint8> ed,
);

typedef _dart_decaf_ed448_convert_public_key_to_x448 = void Function(
  ffi.Pointer<ffi.Uint8> x,
  ffi.Pointer<ffi.Uint8> ed,
);

typedef _c_decaf_ed448_convert_private_key_to_x448 = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> x,
  ffi.Pointer<ffi.Uint8> ed,
);

typedef _dart_decaf_ed448_convert_private_key_to_x448 = void Function(
  ffi.Pointer<ffi.Uint8> x,
  ffi.Pointer<ffi.Uint8> ed,
);

typedef _c_decaf_ed25519_derive_public_key = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> pubkey,
  ffi.Pointer<ffi.Uint8> privkey,
);

typedef _dart_decaf_ed25519_derive_public_key = void Function(
  ffi.Pointer<ffi.Uint8> pubkey,
  ffi.Pointer<ffi.Uint8> privkey,
);

typedef _c_decaf_ed25519_sign = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> signature,
  ffi.Pointer<ffi.Uint8> privkey,
  ffi.Pointer<ffi.Uint8> pubkey,
  ffi.Pointer<ffi.Uint8> message,
  ffi.Uint64 message_len,
  ffi.Uint8 prehashed,
  ffi.Pointer<ffi.Uint8> context,
  ffi.Uint8 context_len,
);

typedef _dart_decaf_ed25519_sign = void Function(
  ffi.Pointer<ffi.Uint8> signature,
  ffi.Pointer<ffi.Uint8> privkey,
  ffi.Pointer<ffi.Uint8> pubkey,
  ffi.Pointer<ffi.Uint8> message,
  int message_len,
  int prehashed,
  ffi.Pointer<ffi.Uint8> context,
  int context_len,
);

typedef _c_decaf_ed25519_sign_prehash = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> signature,
  ffi.Pointer<ffi.Uint8> privkey,
  ffi.Pointer<ffi.Uint8> pubkey,
  ffi.Pointer<decaf_sha512_ctx_t> hash,
  ffi.Pointer<ffi.Uint8> context,
  ffi.Uint8 context_len,
);

typedef _dart_decaf_ed25519_sign_prehash = void Function(
  ffi.Pointer<ffi.Uint8> signature,
  ffi.Pointer<ffi.Uint8> privkey,
  ffi.Pointer<ffi.Uint8> pubkey,
  ffi.Pointer<decaf_sha512_ctx_t> hash,
  ffi.Pointer<ffi.Uint8> context,
  int context_len,
);

typedef _c_decaf_ed25519_prehash_init = ffi.Void Function(
  ffi.Pointer<decaf_sha512_ctx_t> hash,
);

typedef _dart_decaf_ed25519_prehash_init = void Function(
  ffi.Pointer<decaf_sha512_ctx_t> hash,
);

typedef _c_decaf_ed25519_verify = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> signature,
  ffi.Pointer<ffi.Uint8> pubkey,
  ffi.Pointer<ffi.Uint8> message,
  ffi.Uint64 message_len,
  ffi.Uint8 prehashed,
  ffi.Pointer<ffi.Uint8> context,
  ffi.Uint8 context_len,
);

typedef _dart_decaf_ed25519_verify = int Function(
  ffi.Pointer<ffi.Uint8> signature,
  ffi.Pointer<ffi.Uint8> pubkey,
  ffi.Pointer<ffi.Uint8> message,
  int message_len,
  int prehashed,
  ffi.Pointer<ffi.Uint8> context,
  int context_len,
);

typedef _c_decaf_ed25519_verify_prehash = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> signature,
  ffi.Pointer<ffi.Uint8> pubkey,
  ffi.Pointer<decaf_sha512_ctx_t> hash,
  ffi.Pointer<ffi.Uint8> context,
  ffi.Uint8 context_len,
);

typedef _dart_decaf_ed25519_verify_prehash = int Function(
  ffi.Pointer<ffi.Uint8> signature,
  ffi.Pointer<ffi.Uint8> pubkey,
  ffi.Pointer<decaf_sha512_ctx_t> hash,
  ffi.Pointer<ffi.Uint8> context,
  int context_len,
);

typedef _c_decaf_255_point_mul_by_ratio_and_encode_like_eddsa = ffi.Void
    Function(
  ffi.Pointer<ffi.Uint8> enc,
  ffi.Pointer<decaf_255_point_t> p,
);

typedef _dart_decaf_255_point_mul_by_ratio_and_encode_like_eddsa = void
    Function(
  ffi.Pointer<ffi.Uint8> enc,
  ffi.Pointer<decaf_255_point_t> p,
);

typedef _c_decaf_255_point_decode_like_eddsa_and_mul_by_ratio = ffi.Int32
    Function(
  ffi.Pointer<decaf_255_point_t> p,
  ffi.Pointer<ffi.Uint8> enc,
);

typedef _dart_decaf_255_point_decode_like_eddsa_and_mul_by_ratio = int Function(
  ffi.Pointer<decaf_255_point_t> p,
  ffi.Pointer<ffi.Uint8> enc,
);

typedef _c_decaf_ed25519_convert_public_key_to_x25519 = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> x,
  ffi.Pointer<ffi.Uint8> ed,
);

typedef _dart_decaf_ed25519_convert_public_key_to_x25519 = void Function(
  ffi.Pointer<ffi.Uint8> x,
  ffi.Pointer<ffi.Uint8> ed,
);

typedef _c_decaf_ed25519_convert_private_key_to_x25519 = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> x,
  ffi.Pointer<ffi.Uint8> ed,
);

typedef _dart_decaf_ed25519_convert_private_key_to_x25519 = void Function(
  ffi.Pointer<ffi.Uint8> x,
  ffi.Pointer<ffi.Uint8> ed,
);
